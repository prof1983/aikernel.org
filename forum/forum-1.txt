Новый проект AIKernel


Здравствуйте.

Хочу предложить к обсуждению новый проект AIKernel. Цель проекта - разработка модулей с элементами ИИ для использования в других проектах, как не коммерческих, так и коммерческих.
Проект создается с нуля. На данный момент свои мысли по проекту выложил на сайте aikernel.narod.ru . В перспективе будет сайт перенесен на домен aikernel.org.
Домен я уже занял, сейчас ищу подходящий хостинг.

Пытаюсь составить "манифест" проекта с таким расчетом, чтобы он лег в основу "конституции" проекта. На основе "конституции" уже планируется записать правила и собственно выстраивать работу.
Манифест расположен здесь http://aikernel.narod.ru/develop/manifesto/index.ru.html
[quote][b]Манифест проекта AIKernel[/b]
   1. Цель проекта - создание наработок для использования в проектах с элементами ИИ.
   2. Проект является некоммерческим и должен оставаться таковым всегда.
   3. Должна быть обеспечена полная независимость и самоуправление на основе принципов меритократии.
   4. Изменения в манифесте и лицензии может произвести только управляющий комитет и только с согласия лидера проекта.
   5. Основные принципы открытости проекта и не коммерческой основы должны всегда оставаться неизменными.
   6. Должна быть обеспечена защита проекта от саботажа со стороны других компаний и организаций, а так же со стороны отдельных членов правления и отдельных разработчиков.[/quote]
Прошу высказывать у кого какое мнение на этот счет? Что нужно добавить/удалить/изменить?




[quote="Василий"]Привет, хостинг можешь использовать мой - у меня ресурсов хватает, - помогу настроить, да и веселее вместе (ну и бесплатно для тебя опять же). Если хочешь, конечно :wink:[/quote]
Конечно хочу. Нормальный хостинг стоит около 1000 руб в год.
Напишу в личку.
[quote="daner"]"Давайте построим паровоз". Он должен ездить и быть черным.[/quote]
Да. Именно так. Начал с того, что поставил перед собой задачу создания ИИ, но как это сделать не знаю. Поэтому и пришел с вопросами, чтобы самому разобраться и подготовить почву для развития проекта.
[quote="daner"]Я так и не понял, что это должно быть? framework или просто sdk для создание ИИ приложений?
не понимаю так же, почему это надо делать с нуля (в любом варианте) или почему вообще это надо делать (чем плохи уже существующие), короче, в чем идея фикс?[/quote]
В данный момент мне хотелось бы разобраться с лицензиями, правами на интеллектуальную собственность и с прочими подобными вопросами. Так как хочу предложить учавствовать в этом проекте другим, то необходимо четко определить цели проекта, а так же разъяснить ради чего человек будет тратить свое время работая над проектом.
Начать решил с манифеста. То есть основы основ. В манифесте заложены 2 основные мысли:
1. Проект не коммерческий и открытый;
2. Все наработки по проекту будут принадлежать самой организации (фонду) AIKernel.
Здесь я хочу пояснить. Этим манифестом и будущими правилами хочу защитить проект от посягательств извне и от внутренних конфликтов. Хочу защитить проект еще до его создания. Защитить в том числе и от самого себя.

Помоему эти условия обязательно должен понять и принять каждый, кто захочет присоединиться. Дело в том, что каждый преследует свои цели. Кто-то просто хочет иметь готовый продукт на своем компьютере, кто-то заработать много денег от продажи компании, кто-то иметь стабильный доход на пенсии и т.д.

Этим манифестом и будущими правилами я стараюсь сделать условия участия в проекте наиболее интересным для каждого. А именно:
- Для тех, кто хочет получить готовую программу для себя: пожалуйста, создавайте, творите и используйте все наработки абсалютно бесплатно.
- Для тех, кто хочет зарабатывать на продаже продуктов с элементами ИИ: пожалуйста, используйте, но или открывайте код или оплатите труд разработчиков, кто этот код создал.
- Для тех, кто хочет получать доход от своей работы в будущем: если та часть, которую вы создали будет интересна и ее кто-то купит, то вы получите свою часть вознаграждения.
- Для тех, что хочет заработать от продажи проекта кому-либо и тем, кто будет пытаться ставить "палки в колеса", используя патентные или иные махинации: вы здесь ничего не получите.

Конечно большая часть выполнения гарантий и вообще стабильности проекта будет основана на управляющем совете. Здесь стоит надеяться, что люди подберутся честные и достаточно мудрые.
Выборы управляющиго совета предполагаю сделать так же как это реализовано в проектах FreeBSD и Debian. А именно так: управляющий совет выбирают сами разработчики из числа разработчиков путем голосования. Таким образом к власти приходят самые способные. То есть обеспечивается меритократия.

Дополнительно:
http://www.debian.org/vote/ - О голосовании в Debian
http://ru.wikipedia.org/wiki/Меритократия





[quote="daner"][quote]на этом форуме к сожалению разработчиков нет вообще.[/quote]
Не, ну я фигею с таких заявлений. :)

>>>Prof1983
ну... делите шкуру не убитого медведя. И даже при этой дележки, не понимаю, зачем надо придумывать велосипед, а не использовать уже готовые лицензии типа GPL, LGPL, MIT и т.д.

я вам как разработчик (которых как оказалось на этом сайте нет) подобных систем могу сказать, что библиотек очень много. Каждая занимается чем-то своим, но это не особо мешает.
Да конечно есть некоторые (не большие) проблемы по интеграции их друг с другом, но это мелочи и не стоят они того, что бы с нуля переписывать их все в едином sdk пространстве.
Писать надо библиотеку которой еще нет или писать библиотеку, когда у тебя есть что предложить такого, чего нет в других библиотеках (например берете библиотеку с закрытым кодом и пишите с нуля свою, но с открытым... к примеру).
Так же, я бы понял еще написание framework (пока очень часто приходиться писать его с нуля во многих проектах). Ну, т.е. некую систему, API которого позволяет создать Интел.Агента в короткие сроки. Таких проектов тоже далеко не один и есть даже с открытым кодом, но в отличии от просто библиотек, где собраны разные (практически не связанные) функции, которыми можно пользоваться в процессе разработки, общая архитектура агента (а это основа такого framework) пока еще очень и очень спорный вопрос, поэтому каждый такой framework отличается друг от друга достаточно сильно (если конечно это не банальный набор нейронных сетей, деревьев решений и конечных автоматов).

начинать проект надо с его целей и понимания необходимость этого проекта.[/quote]





[quote="Prof1983"][quote="Dimmy"]поэтому предлагаю сюда http://ailab.ru/forum/predlojeniya-proekti-razrabotki/re-google-ai-challenge/381.html#5741 присоединиться чтобы не изобретать велосипед.[/quote]
Предложение правильное. Действительно лучше присоединиться к существующему проекту или взять за основу какую-либо существующую разработку. Признаюсь, что я рассматриваю проект AIKernel, как платформу для проекта ИР и, возможно, других проектов. Но я, к сожалению, пока не встречал живых проектов целью которых было бы создание искусственного разумного существа. 
Что касается проектов deeptown.org, Second Life, Granado Espada, nonapolis.com, и др. - Я не любитель играть в игры. В место этого в основном интересует практическая сторона дела.
Проект AIKernel планирую как набор модулей (библиотек функций) без упора на графику, красоту или удобство для конечного пользователя. Одна из основных целей - разобраться с существующими наработками в области ИИ и оптимизация их для проекта AIKernel или написание аналогичных, если по каким-то причинам существующий проект не может стать частью AIKernel. Если аналога для какого-либо модуля не найдется - тогда придется его писать с нуля.
Если честно, то меня в первую очередь интересуют модули, которые понадобятся при сборке искусственного разумного существа (ИР).

[quote="daner"]ну... делите шкуру не убитого медведя. И даже при этой дележки, не понимаю, зачем надо придумывать велосипед, а не использовать уже готовые лицензии типа GPL, LGPL, MIT и т.д.[/quote]
Я подробно рассматривал лицензии GPL, LGPL, BSD. Остальные лицензии рассматривал поверхностно. В общем-то лицензия BSD - самая свободная. Я взял ее за основу, но с двумя ограничениями: 1. Исключительные права принадлежат фонду AIKernel и не могут быть переданы никому другому. 2. Если человек использует исходный код из проекта AIKernel, то необходимо открыть исходный код изменений и дополнений.
Второй пункт - это принцип, заложенный в GPL, но записанный в более короткой форме.

[quote="daner"]я вам как разработчик подобных систем могу сказать, что библиотек очень много. Каждая занимается чем-то своим, но это не особо мешает. Да конечно есть некоторые (не большие) проблемы по интеграции их друг с другом, но это мелочи и не стоят они того, что бы с нуля переписывать их все в едином sdk пространстве.[/quote]
Согласен. Не нужно переписывать уже существующие библиотеки. Проблема состоит именно в их интеграции в одно целое и налаживание их взаимодействия. Такие библиотеки нужно будет оформлять в модули AIKernel.
При этом, если исходный код какой-либо библиотеки не будет под лицензией AIKernel, то в этом случае сама библиотека не будет частью AIKernel, а будет ее дополнением. Хотя, возможно, нет такой сильной необходимости настаивать на лицензии AIKernel... Может быть стоит выбрать другую лицензию? Подскажите пожалуйста где найти перевод (желательно с разъяснениями) лицензии MIT? Возможно есть еще подходящие варианты?

[quote="daner"]начинать проект надо с его целей и понимания необходимость этого проекта.[/quote]
Верно. Повторюсь: одна из основных целей - создать наработки, которые потом можно будет использовать в других проектах. В частности - проект по созданию ИР, и, возможно, AIAssistant.[/quote]





[quote="Dimmy"][quote="Prof1983"]Что касается проектов deeptown.org, Second Life, Granado Espada, nonapolis.com, и др. - Я не любитель играть в игры. [/quote]

Зря, основной доход с ИИ на текущий момент - это использование в играх.
И чем лучше ИИ тем интереснее игра.

Тот же СТАЛКЕР к примеру.
http://www.stalker-portal.ru/page.php?id=204
А вообще, где-то в сети было интервью с разработчиками сталкера и в частности оного знаменитого ИИ в игре.
Без него игра была бы не такая насыщенная, а следовательно отзывы бы были хуже, фанов меньше => продаваемость игры меньше.

http://en.wikipedia.org/wiki/Game_artificial_intelligence
http://ru.wikipedia.org/wiki/Игровой_искусственный_интеллект

[color=green][size=75]Добавлено спустя 9 минут 15 секунд:[/size][/color]

Главная задача ИИ — не выиграть у игрока, а красиво ему отдаться. (с) Тимур Бухараев, Nival[/quote]





[quote="Prof1983"][quote="daner"]
[quote="Prof1983"]
Согласен. Не нужно переписывать уже существующие библиотеки. Проблема состоит именно в их интеграции в одно целое и налаживание их взаимодействия. Такие библиотеки нужно будет оформлять в модули AIKernel.
При этом, если исходный код какой-либо библиотеки не будет под лицензией AIKernel, то в этом случае сама библиотека не будет частью AIKernel, а будет ее дополнением.
[/quote]
Ну а почему их просто нельзя использовать? зачем нужен AIKernel? Ну нужно мне с графикой работать -- беру OpenCV, нужно аппроксимацию -- тоже выбираю подходящую, ну т.д.
[/quote]
Просто использовать конечно можно. Но по моему будет лучше, если собрать такие библиотеки, алгоритмы, функции и другие разработки в единую систему. Ну или по крайней мере структурировать. Плюс к этому добавить свои разработки.

[quote="daner"]
[quote="Prof1983"]
[quote="daner"]начинать проект надо с его целей и понимания необходимость этого проекта.[/quote]
Верно. Повторюсь: одна из основных целей - создать наработки, которые потом можно будет использовать в других проектах. В частности - проект по созданию ИР, и, возможно, AIAssistant.[/quote]
нееее... смотри выше. этого не достаточно.[/quote]
Не совсем понятно: чего недостаточно?

Ладно. Чувствую, что предложение никого пока не заинтересовало. Попробую пока заняться разработкой архитектуры и базового API, а там видно будет.

Когда дело доходит до реализации, то один из главных вопросов - это язык реализации кода. Самые популярные языки, по моему, это: C/C++, Java, C#, Delphi.
Я программист Delphi и изучить какой-то другой язык до сих пор времени не нашлось. Мне кажется, что самый лучший вариант языка для AIKernel был бы язык объединяющий удобство Java, C# и Delphi, но при этом должен быть простым в плане использования в других проектах, с возможностью компиляции на многих платформах, быть достаточно простым и достаточно гибким. В общем, по моему, лучшим вариантом был бы чистый C.
Есть проект, который объединяет удобство C# и Java с возможностями С - это проект Vala.
http://live.gnome.org/Vala
http://ru.wikipedia.org/wiki/Vala
Но при его компиляции и для его выполнения используется библиотека glib и другие библиотеки с лицензией GPL. В соответствии с этой лицензией не получится напрямую использовать программы написанные на Vala как коммерческие проекты с закрытым кодом, если это потребуется.[/quote]




[quote="Prof1983"][quote="daner"]То что используются библиотеки glib -- не мешает продукту быть коммерческим. У GTK+ лицензия LGPL, т.е. если вы используете программы (библиотеки) под этой лицензией (не их код, а просто линькуетесь к ним) на вас это не накладывает никаких ограничений.[/quote]
На сколько мне известно лицензия GPLv2 и GPLv3 не разрешают линковать или как-либо использовать библиотеки (LIB, DLL и SO) в проприетарных проектах. Лицензия LGPLv2 и LGPLv3 запрещает линковку (LIB) в закрытые программы, но разрешает динамическое (и наверное статическое тоже) связывание с библиотеками (DLL и SO).

Лицензия GPLv3 более жестко ограничивает возможности чем GPLv2. Поэтому от использования программ под GPLv3 стараются всячески уйти в проектах BSD и Apple iOS. На сколько я понимаю именно из-за GPLv3 активно развивают давно заброшенный проект Portable Compile Collection (PCC), который будут использовать для компиляции BSD ядра и программ с лицензией BSD. До этого использовали GCC (под GPLv2).

На сколько я понимаю, компиляция BSD программ является не законной, т.к. при компиляции с помощью GCC используются стандартные библиотеки функций Си (std*), которые распространяются в GCC под GPL. И они естественно становятся частью программы. Поэтому теперь, все программы, скомпилированные с помощью GCC, должны распространятся под GPL.

[quote="DCV"]Я начал в Wiki-разделе открытый бесплатный проект по созданию ИИ в предметной области "быт человека". http://ai.obrazec.ru/wiki/index.php?tit ... 0%BA%D0%B0
О том во что проект может развиться пока рано говорить. Но считаю, что в случае успешного продвижения проект может стать коммерческим.[/quote]
Честно говоря я не совсем понял в чем суть проекта "быт человека". Главный вопрос - чем вас не устраивает простое описание окружения человека (его "быт") в виде онтологии? Для этого можно использовать визуальные редакторы, такие как Protege.

[quote="DCV"]Я не согласен. Общие проекты нужно делать на С#. На C# есть хороший сборщик мусора. С++ намного сложнее. Java использует byte code. На Delphi долго писать begin и end. А сколько людей знают, что такое Qt?[/quote]
В этом вопросе я придерживаются политики GNOME. А именно: программы, входящие в проект GNOME должны быть написаны на компилируемом языке. Промежуточная компиляция осуществляется в .o файлы, которые могут быть использованы в составе другой программы на другом языке. Хорошо для использования подходят языки Си (чистый Си), FreePascal. А объектно-ориентированные языки, такие как C++ не подходят, т.к. внутренняя структура объектов очень сложна для использования в программах на других языках. Хотя и компилируются исходники C++ тоже в .o файлы.

Отсюда вывод: чистый Си и FreePascal - это хорошо, С++ - не желательно, а C#, Java и подобные - не допустимо, т.к. для своей работы требуют других внешних программ для выполнения. Это идеология GNOME.

Для проекта AIKernel четких правил на этот счет нет. Однако, для уменьшения возможных проблем я бы не рекомендовал использовать зависимые от кого-то инструменты. В частности патенты на многие вещи из C# принадлежат Microsoft. Патенты на реализацию некоторых вещей из Java теперь принадлежат Oracle, зависимость от GCC может привести к невозможности использования ваших собственных наработок в закрытых проектах (если вы в своих работах использовали частично чужой GPL код). В общем я бы рекомендовал или чистый Си или FreePascal и библиотеки под лицензиями BSD, MPL, MIT, Appache, но не GPL (особенно не GPLv3).

Вот так-то.[/quote]




[quote="Prof1983"][quote]использование gcc ТОЧНО не создает никаких проблем с лицензированием программ[/quote]
Сейчас попробовал поискать зачем развивают компиляторы под BSD, если есть готовый GCC. Ответа не нашел. Получается PCC "еще один велосипед". Тем более, не понятно зачем нужен PCC, если уже есть компиляторы под BSD такие как clang.
Скорее всего никаких проблем в использовании GCC при компиляции проприетарных программ нет, но вопрос остается открытым: "зачем столько компиляторов под BSD, если уже есть GCC под GPL"?

[quote]MONO, который пока застрял на достаточно старой версии С#[/quote]
MONO застрял, по моему, из-за лицензионных ограничений на реализацию классов из MS .NET Framework. Об этом Столлман писал в одном из своих обращений.

[quote]Так что, остается именно С++[/quote]
В общем-то наверное да. С++ сейчас самый популярный и продвинутый язык с поддержкой использования разных парадигм программирования. Однако я в своих проектах стараюсь использовать простое процедурное программирование, а не лепить объекты везде где это где это нужно и не нужно. В частности, те объекты, которые ни от кого не наследуются и которые никто не наследует не стоит записывать в виде классов.

Например такой класс (Delphi, Object Pascal):
[code]type
  TExampleClass = class
  private
    FProp1: Integer;
    FProp2: string;
  public
    procedure ExampleProc;
  end;
  ...
procedure TExampleClass.ExampleProc;
begin
  ...
end;[/code]
   
можно записать так

[code]type
  PExampleRec = ^TExampleRec;
  TExampleRec = record
    Prop1: Integer;
    Prop2: string;
  end;
...
procedure Example_ExampleProc(Obj: PExampleRec);
begin
...
end;[/code]

Разницы в быстродействии, функциональности и т.д. - никакой. Зато, скомпилированные .o файлы можно относительно легко использовать в программе на другом языке.[/quote]





[quote="Prof1983"][quote="DCV"]...похож на онтологию Лената, и это тупиковый подход для ИИ.[/quote]
Я не думаю, что это тупиковый подход.

[quote="DCV"]Человек использует язык для передачи информации, но не для хранения информации в мозге.[/quote]
Как именно и в каком виде происходит хранение и обработка данных и знаний в мозге человека до сих пор еще не ясно. Но в общем-то это не важно. Живой мозг и компьютер работают по разному, поэтому вид хранения информации и алгоритмы обработки этой информации, скорее всего, будут совершенно разными. При этом вид представления информации и вид хранения информации - несколько разные вещи. Ту же онтологию можно записать в текстовый файл, в XML виде, в БД в виде приплетов и др. При этом представление информации в виде графа - это тоже один из видов записи. Онтологию можно записать (или нарисовать) и в виде графа тоже.

[quote="DCV"]Я не знаю о визуальном редакторе Protege. Думаю, всем будет интересно, если Вы о нем расскажите или дадите ссылки в интернете.[/quote]
Вот ссылки из запроса из ya.ru:
http://protege.stanford.edu/
http://ru.wikipedia.org/wiki/Protege
Вот красивая картинка отображения онтологии (OWL) в графическом виде (в виде графа):
http://protege.stanford.edu/plugins/owl/images/OWLViz-BackpackersDestination.png

Читайте, изучайте. Я сам лишь поверхностно знаком с Protege.

[quote="DCV"]Язык беседы не должен совпадать с ЕЯ, но должен быть близким к ЕЯ.[/quote]
Этот вопрос у меня тоже не раз возникал. Я пришел к выводу, что нужно для начала использовать что-то на подобие Simple English или Basic English для общения с программой.

[quote]Бе?йсик-и?нглиш[1] (англ. Basic English — базовый английский) — международный искусственный язык на основе английского языка, созданный в 1925 году британским лингвистом Чарльзом Огденом.
Основное отличие от английского языка — сокращённый словарь (850 слов). Английская грамматика в бейсик-инглиш осталась в основном без изменений.
Бейсик-инглиш схож с Simple English, на котором существует отдельный раздел Википедии[/quote]
http://ru.wikipedia.org/

Написать общение на ЕЯ с использованием Simple English или Basic English намного проще, чем с использованием русского ЕЯ. Виктор пробовал создать свой язык для общения - BABYLON, за тем ECLIPSE. Но ECLIPSE стал, по сути, языком записи интерпретируемых скриптов для AIAssistant.

[quote="DCV"]Классы, созданные на одном языке MS Visual Studio, успешно могут использоваться на других языках MS Visual Studio. А работа без ООП над таким сложным проектом просто невозможна.[/quote]
Не путайте теплое с мягким. В MS Visual Studio используется только C++. Я же говорю об использовании разных языков: Си, Perl, Python, Rubi, Pascal и т.д. Классы, в разных языках имеют разное внутреннее представление. Из-за этого скомпилированные промежуточные классы, написанные на одном языке, очень трудно использовать в программах на других языках.

[quote="DCV"]C# требует CLR (Common Language Runtime) среда выполнения. Устанавливается при установке .Net Framework, которую можно бесплатно скачать с сайта Microsoft.[/quote]
Лично я стараюсь придерживаться принципа, чтобы программа могла компилироваться и работать на любом оборудовании и на любой платформе. Например программы на Си могут (теоретически) быть скомпилированы для использования в микроконтроллере какого-нибудь примитивного робота, а использование других языков будет проблематичным. Аналогично нет никакого смысла реализовывать CLI виртуальную машину или JVM для использования в маломощных устройствах.

[quote="DCV"]Мне сказали, что Java работает медленней, поэтому лучше не использовать из-за низкой производительности.[/quote]
Java медленее по сравнению с чем? Если сравнивать с плохо написанной программой на Си или C++, то разницы, скорее всего, не заметите. Если сравнивать с .NET, то Java работает так же. Если сравнивать с Mono, то в Linux ядре есть такая штука как JIT - она позволяет выполнять байт-код Java почти так же быстро как и нативные приложения. Поэтому использовать Java на Linux предпочтительнее, чем Mono.

[quote="DCV"]Какие есть компиляторы чистого C? И какие возможности у чистого C?[/quote]
Компиляторов очень много. Существуют компиляторы практически под любую платформу и для любого оборудования.
Для обычных приложений можно использовать любой C++ компилятор (например MS Visual Studio в Windows).

[quote="DCV"]...лучше использовать бесплатный C, и бесплатные библиотеки. А возможно, лучше купить один лицензионный компилятор MS C++ или MS C#...[/quote]
И еще раз не путайте теплое с мягким. Язык и компилятор - это разные вещи.[/quote]




[quote="Prof1983"]Еще хочу отметить про виды представления и записи информации и знаний в компьютере.

[b]Базовый вид представления информации[/b]

Если попытаться посмотреть на все виды представления информации, то можно прийти к выводу, что в компьютере вся информация хранится и передается в виде последовательности байтов разной длины. Отсюда следует вывод, что базовым видом представления информации и знаний можно (и нужно) принять именно последовательность байтов. Другими словами, любую информацию и любые знания можно записать в виде массивов байтов.

По сути такие последовательности байтов, в ОС - это есть файлы. Аналогично во всех основных СУБД запись данных производится аналогично - в виде блоков в которых находятся некоторые данные. Это реализовано и в MySQL и в Firebird и в DB2. Реляционный же вид представления данных или другой в БД, в свою очередь, является внешней оболочкой для внутреннего движка БД.

У каждого такого блока в файловой системе ОС есть уникальное имя (путь), внутри БД - уникальный идентификатор.

Я считаю, что самым правильным подходом для создания ИИ систем будет создание единого вида базового представления данных, информации и знаний. А именно - в виде аналогичном записи данных в СУБД. С назначением каждой единице информации уникального идентификатора. Идентификатором внутри одной БД может быть простое целое число. Однако, не следует ограничивать хранение информации только в одной БД. Поэтому предлагаю использовать гибридный идентификатор вида: //localhost/path/to/db/123456
где localhost/path/to/db/ - путь к БД, 123456 - уникальный номер записи внутри этой БД.

Таким образом можно будет обратиться к каждой конкретной записи данных на локальной машине, а так же в сети, используя запись вида: //aikernel.org/path/to/db/12345 или //username:password@aikernel.org/path/to/db/12345. При этом можно предусмотреть разные протоколы доступа к записям: http://aikernel.org/path/to/db/123456, ftp://aikernel.org/path/to/db/123456 или myprotocol://aikernel.org/path/to/db/123456.

Однако, такой вид представления данных, не дает ничего принципиального нового. Требуется уточнение структуры данных каждой такой записи, так же требуется указание о том как использовать информацию, которая там хранится и т.д. Предлагаю указывать это записывая тип блока данных. Типом блока данных может служить указатель на другой блок данных в котором будет содержаться информация о структуре данных, методах его обработки и использования. Такой блок данных я назвал "сущность" (от слова существует).

[b]Вид представления данных в виде сущностей[/b]

В общем сущность в программе можно записывать примерно так:
[code]type
  TAEntity = packed record // Сущность
    EntityID: Integer; // Идентификатор сущности (блока данных) в локальной БД
    EntityType: Integer; // Тип сущности - идентификатор в локальной БД
    DataLength: Integer; // Размер блока данных
    Data: Pointer; // Указатель на блок данных
  end;[/code]

В общем-то такой вид представления информации не многим отличается от простой записи данных без указания типа. Однако, задав базовые типы данных, можно будет использовать их в разных программах с элементами ИИ. Таким образом обеспечится взаимодействие различных ИИ систем. А это, в свою очередь, на один шаг приблизит нас к решению основной задачи - к ИР.

[b]Основные типы сущностей[/b]

Какие именно должны быть основные типы данных я, до сих пор, еще не знаю.
Возможно, что нужно, дать программе возможность хранения и обработки простых типов данных, таких как Integer, Float и т.д.
Например можно создать первую БД сущностей (//aikernel.org/entities/base0.xml) с такими записями:
[code]0 - Зарезервировано
1 - Ссылка на внешнюю БД сущностей
2 - Byte (UInt8)
3 - Word (UInt16)
4 - LongWord (UInt32)
5 - UInt64
...
8 - Int8
9 - Int16
10 - Int32
...
16 - String (WideString, UTF16)
...
32 - OntologyTriplet (Субъект-Предикат-Объект)
...[/code]

В файле эти данные можно записать, например, в таком виде:
[code]<xml>
  <entity id=2 name="Byte" />
  <entity id=10 name="Int32" />
  ...
  <entity id=32 name="OntologyTriplet" comment="This is triplet for ontology">
    <data>
      <node name="Subject" type=10 />
      <node name="Predicate" type=10 />
      <node name="Object" type=10 />
    </data>
  </entity>
</xml>[/code]

При этом сами данные, внутри программы, можно записывать примерно так:
[code]const
  // Ссылка на сущность Byte во внешней БД
  AByteType: TAEntity = (
    EntityID = 2;
    EntityType = 1;
    DataLength = {Размер данных};
    Data = {Указатель на строку "//aikernel.org/entities/base0.xml/2"}
  );
  // Ссылка на сущность OntologyTriplet во внешней БД
  AOntoTripletType: TAEntity = (
    EntityID = 32;
    EntityType = 1;
    DataLength = {Размер данных};
    Data = {Указатель на строку "//aikernel.org/entities/base0.xml/32"}
  );
  // Объект с полезными данными
  Triplet1: TAEntity = (
    EntityID = 12345; // Уникальный идентификатор в локальной БД
    EntityType = 32; // Тип 32 - это триплет
    DataLength = 12{Размер данных};
    Data = {Указатель на блок данных с указанием идентификаторов Субъекта, Предиката и Объекта. Например (1234, 1235, 1236)}
  );[/code]

С одной стороны, такой вид представления информации усложняет работу. Однако, если мы сможем прийти к единому виду представления и обработки информации, то выиграют все. Вид представления в виде сущностей, по моему, вполне может для этого подойти.[/quote]





[quote="Prof1983"][quote="DCV"]С#:  Объявляем класс TAEntity и группируем в нем данные:[code]class TAEntity
{
    // Объявление переменных - членов класса
    int entityID;
    ....
}[/code][/quote]
Можно и в виде классов реализовать, но я все-таки за простые структуры (struct,record) данных. А работу с данными можно организовать не методами класса, а простыми процедурами. Все дело в том, что если вы будите писать на C++, .NET, Delphi или другом объектном языке, а я буду писать на чем-то другом, то мне использовать ваши разработки будет очень проблематично. И наоборот. А вот программы, написанные на Си можно использовать практически везде. И в Delphi и в C++, и даже в .NET и Java.

[quote="ЭГТР"]Мы конечно делаем не ИИ, а ИР.[/quote]
Вы не правы. Мы лишь ищем методы, которые позволят нам понять в каким направлении нужно двигаться, чтобы в отдаленном будущем создать ИР. :)

[quote="DCV"]А с возрастом занялся благотворительностью, в частности борьбой с малярией в Африке.[/quote]
На сколько мне известно, миллиардеры, живущие в США занимаются благотворительностью не по собственной воле. Вернее им выгоднее отдать часть прибыли на какие-то социальные программы, чем платить большие налоги правительству США.

[quote="DCV"]Какой компилятор С++ Вы используете? Я знаю, что есть Borland C++ Builder, CodeGear C++ Builder, Microsoft C++.[/quote]
Для обучения я использую MSVS2010Express и RAD Studio 2010. А для сборки готовых программ, наверное, будет более правильно использовать Clang+LLVM или PCC (pcc.ludd.ltu.se).[/quote]





[quote="Prof1983"][quote="vchc"]Вряд ли можно навязать кому-нибудь из разработчиков лицензию, если он этого не хочет.
...в рамках проекта можно будет вести и научные изыскания и реализовывать непрограммные решения.[/quote][quote="vchc"]Например вам интереснее заниматься программными решениями, я могу заняться теоретическими решениями, кто-то обеспечением и так далее.[/quote]
Полностью согласен. Накладывать какие-то лишние ограничения не правильно. Однако есть некоторые моменты, которые мне кажутся сейчас очень важными. Я имею в виду вопрос лицензий. Пока этот вопрос не имеет значения, т.к. еще нет какого-либо продукта из-за которого могли бы возникать претензии. Однако, я стараюсь продумать заранее все риски и предусмотрительно выбрать правильные лицензии, а так же не допускать попадание в зависимость от какой-либо закрытой программы или технологии. По моему, должна быть обеспечена независимость хотя бы для базовой части (для ядра) системы. При этом некоторые "модули" могут распространяться под не совсем свободными или даже проприетарными лицензиями.[/quote]





[quote="Prof1983"]Чтобы не перепечатывать все свои мысли заново решил, что проще указать ссылки. Надеюсь правилами форума это не запрещается. Вот в этом посте еще можно почитать про мое видение проекта AIKernel
http://ai.obrazec.ru/forum/viewtopic.php?p=28669#p28669
и еще вот здесь
http://gotai.net/forum/Default.aspx?postid=50095#50095[/quote]





[quote="Prof1983"][quote="victorst"]ваш проект называется "Зернышко", но все гипнотические телодвижения вы делаете вокруг шелухи этого зернышка.[/quote]
Виктор прав. Слово Kernel действительно переводится как ядро, ядрышко, зернышко. И действительно наши движения происходят вокруг да около разных направлений ИИ, с метанием от одного подхода к другому. И самого "зернышка" из-за всей этой шелухи пока не видно. Да и не совсем понятно пока как можно выделить это "зернышко" среди всех существующих работ в области ИИ.

Я писал ранее, что методики создания ИР пока нет, поэтому не известно пока какой именно подход окажется верным. Возможно потребуется гибридный подход из разных составляющих. Например: нейросеть на входе + преобразование в семантический вид + логический вывод + решение теорем + генетический аппарат для обучения и т.д.
Целью проекта AIKernel является выделение общих вещей для разных подходов, поиск точек взаимодействия и т.д. Другими словами, целью проекта AIKernel является создание универсального ядра для разных "модулей" ИИ.[/quote]




[quote="victorst"][quote="Prof1983"]Целью проекта AIKernel является выделение общих вещей для разных подходов, поиск точек взаимодействия и т.д. Другими словами, целью проекта AIKernel является создание универсального ядра для разных "модулей" ИИ.[/quote]Состыковать нестыкуемое? Круто.
Только когда дело неизбежно дойдет то той сути, о которой я говорил, камнем преткновения встанет набор используемых в проекте набор аксиом. А именно:
1. Что такое интеллект, разум....
2. Что такое знания.
3. Как эти знания организованы, связаны между собой.
4. Основный принципы обработки знаний.
Я уже не говорю о более сложных материях, например, о личностных качествах ИИ, ИР (темперамент, характер, эмоциональность и т.д. и т.п.) Если думаете, что этого всего ИР не нужно, то глубоко ошибаетесь. Думаете, случайно природа придумала темпераменты или другие вроде бы ненужные атавизмы человеку? 
И произойдет все как обычно - форма есть,а содержание, которое каждый хотел бы вложить свое, в это прокрустово ложе не укладывается.
 Я считаю, что модули должны быть созданными исходя из определенной доктрины, основанной на вышеуказанном списке аксиом, а не на концепции стыковки на уровне данных. Модулей на основе данных пруд пруди. Но в данном случае от них мало проку.
Исходя из вышесказанного я в своем проекте делаю модули, основанные на моем списке аксиом, который я много раз описывал на разных форумах и на этом особенно часто.[/quote]





[quote="victorst"]Я покопался в архивах и нашел письмецо ко мне датированное 2005 годом.Хорошая тогда была команда у Моренко. И готовую программу их я изучал. http://www.elaira.ru/ 
Странно, но сейчас я ощутил, что я и Моренко работали тогда действительно над чем-то аналогичным. И лишь сейчас я прихожу к выводу, что необходимо делать надстройку над параллельной динамической сетью нейронов/демонов, чтобы реализовать мои в том числе и онтологические замыслы. Задумка у Моренко была неплохая, однако. Они писали на Delphi. Что-то подобное сделал и Дмиртий Шуклин в своем Cerebrum. Но он сейчас сильно озабочен неудачным выбором языковой платформой .NET. Кстати Дмитрий всем предлагал свой проект как основу для ИИ разработок. В нем только ядро на С было закрытым тогда, а .NET код надстройки кажется был свободным.
Решил выложить письмо ко мне без купюр
". 
Здравствуйте Виктор!

Прошу прошения за медлительность с ответом, я сейчас занят некоторыми административными делами и руки до почты не доходят (в таком режиме скорее всего до середины ноября или даже до конца ноября).

> 
> СЛЕГКА познакомившись с материалами, выложенными на той же ветке 
> форума, я заинтересовался ими.
> 
> Я разрабатываю систему ИИ, которая основывается на базе знаний и 
> параллельных процессорах. Часть или все процессоры могут эмулироваться 
> на одном строго последовательном реальном процессоре (РП) с 
> последовательным циклом обработки виртуальных процессоров (ВП). Все 
> процессоры образуют общее логическое поле виртуальных процессоров, 
> количество которых сейчас определяется 64 битным адресом, но легко 
> может быть расширено.  Группы ВП, находящиеся на одном РП, могут 
> прозрачно работать с другими группами ВП, расположенными на других РП. 
> ВП может выполнять какую-либо работу, только если в него будет помещен демон. Демон частично аналогичен Вашему Эктору.
> 
> Все это похоже на Ваш проект, но только отчасти. Вы делаете упор на 
> техническую составляющую: сверхраспараллеливание. Но тут нужно 
> разобраться, что требует распараллеливания и как это должно происходить.

Все же несколько уточню - основной упор лично я делаю не на технику, а на организацию команды. Что касается техники, то тут мы пытаемся подготовить среду разработки, которая бы накрыла потребности разработчиков (входящих в команду) как можно более полно. 

> 
> Оставим в стороне вопросы разрядности адресации к Боксам и Экторам. Вы 
> говорите о динамическом создании нейронных сетей, но, однако, создаете 
> фиксированную сеть со строго определенными связями и их количеством у 
> каждого бокса. Мне кажется, что в этом кроется огромная проблема для

Нет, в каждом узле создается фиксированная заготовка, но фиксированность ее только в том смысле, что есть ограничение на максимальный размер размещаемой структуры, так что это совершенно естественная фиксированность, присущая любому реальному устройству. Остальные ограничения носят тоже самый общий характер, типа стандартные математические действия, фиксированный формат "информационного кванта" (не запрещающий, очевидно, лепить сложные структуры из множества квантов) и т.д. На этом поле можно задавать любые как фиксированные так и динамические структуры, но это уже в компетенции разработчиков, использующих данную среду для решения своих задач (да кстати, среда называется не "Феникс", пока есть только условно-рабочее название "Project AI";  "Феникс" это из предыдуших разработок - система мониторинга).

> будущего Вашего проекта. Вы не разделили маршрутизаторы сети от 
> операционных блоков. К каждому маршрутизатору может быть подключен 
> более чем один операционыый блок. И саму топологию сети приходится 
> тщательно создавать в редакторе.
> 

Здесь не совсем точно, но это уже надо объяснять более предметно и подробно, если у Вас найдется время и желание, это можно будет сделать.

> Но самое главное заключается в предмете работы - в нейросетях. У меня, 
> несмотря на наличие параллельно работающих демонов, вся нейросеть в 
> явном виде не создается. Ее фрагменты динамически появляются в виде 
> динамически создаваемых демонов в зависимости от текущего состояния 
> системы и наличия входных данных. Это позволяет дополнительно 
> экономить ресурсы. При этом основная нагрузка падает на структуру 
> знаний, хранящихся в базе. Кроме того, классические нейросети эквивалентны рефлекторной дуге животных или человека.
> Этого недостаточно для выполнения функций, аналогичных ВНД человека и 
> сложной аналитической работы.
> 
> Мне непонятна цель создания Вашей системы PHОENIX. С ее помощью Вы 
> исследуете нейросети или с помощью динамически создаваемых нейросетей 
> уже исследуете какие-либо сложные процессы, например, из области физики?
> 

Основная цель - продвижение в направлении создания ИИ, причем весьма желательно обеспечить продвижение таким образом, чтобы было видно и направление движения и скорость. То есть хотелось бы не блуждать в полной темноте совершенно наугад, даже не замечая что одно и тоже место пройдено уже несколько раз, а выработать хоть какую то осмысленную политику. 
На текуший момент работа концентрируется на направлении создания достаточно удобной среды, функциональность которой позволит СОГЛАСОВАННО участвовать в проекте большой команде разработчиков. Работа по сбору команды начата совсем недавно, и пока мягко говоря в полсилы (это все таки следующий этап, сначала надо завершать подготовительные мероприятия).

>  
> 
> Я никоим образом не хотел бы принизить актуальность и сложность 
> выполняемой Вами работы, а также лично обидеть кого-либо случайно 
> высказанными категоричными высказываниями.

Обидеть кого либо из существующей команды крайне сложно, всякая политизированность и недосказанность внутри команды только мешают работе, а то что все плохо и так все знают, этим никого не удивишь. Так что у нас принято говорить не особо задумываясь о стиле и выражениях, главное по возможности точно передать смысл.

> 
> Возможно, Вас заинтересует и моя работа, хотя подробной документации я 
> не имею. Если есть хотя бы небольшая вероятность взаимовыгодного 
> сотрудничества, ответьте мне.
> 

С нашей стороны вероятность близка к 1. Но одновременно с этим хочу сразу отметить - в существующей сейчас команде все абсолютно самостоятельны и независимы, никакого единого руководства нет (и не должно быть), максимум что может быть - это координация действий команды (или внутреняя). На текущий момент координатором я работаю (точнее прям счас не работаю, но через месяц вернусь).

Best regards,
 Alexsandr A. Morenko"[/quote]




[quote="Prof1983"][quote="vchc"]на данный момент меня куда больше занимают принципы и архитектура самого ядра.[/quote]
Я попытался описать основные принципы архитектуры вот тут: http://aikernel.org/develop/architecture/index.ru.html . Это не окончательный вариант и, возможно, что все это нужно будет изменить. Тем более, на данном этапе, это будет сделать довольно легко. А вот после старта реализации менять принципы и архитектуру будет крайне не приятно (придется переписывать уже реализованный и отлаженный код). Попробую прокомментировать, что имел в виду. И так, по порядку:
[quote][b]Основное[/b]
[list][*]Программы и модули AIKernel должны быть написаны на языке, который компилируется в выполняемый машинный код. То есть для выполнения программы не должно требоваться наличие каких либо сторонних виртуальных машин и т.п.[/quote]
Не хочу чтобы проект был ограничен какой-то одной платформой. По крайней мере базовая часть, по моему, должна иметь возможность компилироваться и для ПК и для микроконтроллеров.[/list]
[quote][b]Сборка[/b]
[list][*]Сборка - это набор программ и модулей, собранных в одном месте.
[*]Сборка создается, как правило, для решения определенных задач.
[*]Сборка может быть представлена в виде одной программы или системы из нескольких программ.[/list][/quote]
Сборки - это готовые к применению продукты. Каждый может собрать систему "под себя" с необходимым ему набором функционала. Кто-то может даже создавать коммерческие сборки с добавлением каких-то дополнительных модулей, или предоставлять коммерческую поддержку.
[quote][b]Ядро[/b]
[list][*]Ядро - это набор основных модулей для работы программы или системы.
[*]В каждой сборке может быть различный набор базовых модулей.[/list][/quote]
Какие именно модули должны входить в состав ядра мне пока не ясно. Но каждый сможет собрать как ядро, так и сборку "под себя".
[quote][b]Модуль[/b]
[list][*]Модуль - это обособленный набор процедур и функций. Модуль включает в себя так же необходимые данные для работы модуля.
[*]Модуль может быть представлен в виде составной части основной программы, в виде дополнительной библиотеки или в виде отдельной программы.
[*]Взаимодействие модулей осуществляется прямым вызовом процедур и функций, а так же путем передачи сообщений и команд.
[*]Модуль может быть подключен к системе в момент запуска или после запуска, во время работы.[/list][/quote]
Модуль - это аналог библиотеки функций (lib), но функции модулей AIKernel, в первую очередь, должны быть нацелены на обработку знаний. Ниже я опишу свое мнение каком виде лучше представить знания в AIKernel.
[quote][b]Runtime (минимальная базовая среда выполнения)[/b]
[list][*]Минимальная базовая среда выполнения AIKernel - это минимальный набор базовых функций, обеспечивающих запуск и работу модулей.
[*]Минимальная базовая среда выполнения так же содержит в себе информацию о загруженных модулях.[/list][/quote]
Я предполагаю, что минимальный набор функций должен быть действительно минимальным и включать примерно такие функции:
[code]Runtime_Modules_AddModule;
Runtime_Modules_DeleteModule;
Runtime_Modules_GetByName;
Runtime_Modules_Count;[/code]
Кстати, по наименованиям типов, функций и по стилистике написания кода - это отдельная темя для обсуждения. Я понимаю, что можно создавать классы и реализовывать методы. Тогда можно вызывать методы объекта и это будет более красиво написано:
[code]Runtime.Modules.AddModule;
Runtime.Modules.DeleteModule;
Runtime.Modules.GetByName;
Runtime.Modules.Count;[/code]
или
[code]Runtime->Modules->AddModule;
Runtime->Modules->DeleteModule;
Runtime->Modules->GetByName;
Runtime->Modules->Count;[/code]
Но я за простую реализацию на простом процедурном языке (например на чистом Си).
[quote][b]Хранение данных[/b]
[list][*]Для хранения данных могут использоваться все доступные средства.
[*]Основные модули AIKernel должны использовать только открытые и свободные стандарты и форматы передачи и хранения данных.
[*]Для всех остальных модулей и программ, так же, желательно использование только открытых и свободных стандартов и форматов.[/list][/quote]
Я стараюсь сразу отгородится от всех потенциальных проблем в будущем. Поэтому буду настаивать на использовании свободных лицензий и свободных форматов в проекте AIKernel!
[quote][b]Знания[/b]
[list][*]Знания в системе могут быть представлены в разных видах.
[*]Желательно представление знаний в виде сущностей.
[*]Различные данные и знания могут храниться на локальной машине, в удаленном хранилище, а так же могут использоваться распределенные средства хранения данных и знаний.[/list][/quote]
По поводу сущностей я уже писал где-то на форуме. Идея в том, что каждую элементарную единицу знаний записывать в виде массива байтов + назначать уникальный идентификатор + указывать тип сущности (для того, чтобы знать как его следует обрабатывать). А для хранения в памяти можно предложить такую структуру для сущности:
[code]type
  TAEntity = packed record
    EntityID: Integer;
    EntityType: Integer;
    DataLength: Integer;
    Data: Pointer;
  end;[/code]
При этом в таком виде можно будет записать любую информацию. В частности каждой отдельной сущностью могут быть записаны классы, индивиды(объекты) и их связи для онтологии.
[quote][b]Сущности[/b]
Привожу цитаты из книги "Общение с ЭВМ на естественном языке". (стр. 133)
3.2. Модель окружающей среды. Исходные понятия.
3.2.1. Основные понятия. Рассмотрение основ начнем с понятия "сущность". Под сущностью будем понимать объекты, отношения, множества, ситуации, события, моменты времени и т.п. Другими словами, не существует ничего, что не являлось бы сущностью. В процессе описания выделим из всего множества сущностей те, которые будут нас интересовать.[/quote][/quote]




[quote="Prof1983"][quote="victorst"][quote="vchc"]камнем преткновения встанет набор используемых в проекте набор аксиом. А именно:
1. Что такое интеллект, разум....[/quote]Полностью согласен.[/quote]
А я не согласен. И могу объяснить почему. Дело в том, что мы еще не пришли к единому мнению по поводу самых основ. А именно базовых принципов построения проекта, его целей и путей реализации. Рано еще спорить о том что такое интеллект и разум. Иначе на этом споре все и закончится, т.к. у каждого свое мнение на этот счет и у каждого свой набор инструментов, с которым он знаком. А главная проблема в том, что мы не хотим поставить себя на место собеседника и понять почему с его точки зрения должно быть именно так, а не иначе. Прежде нужно научиться слушать и слышать друг друга, нужно научиться разговаривать на одном языке, научиться пользоваться одинаковыми инструментами и технологиями.

О какой совместной разработке Искусственного Разума мы говорим, если каждый будет его реализовывать своим инструментарием без обеспечения взаимодействия с разработками других участников? Пожалуйста, я бы не хотел, чтобы в этой ветке шло обсуждение вопросов что такое "интеллект" и что такое "разум". Это долгий разговор и для этого можно завести отдельную ветку. Аналогично можно завести ветки для обсуждения самого "крутого" языка программирования или тему для обсуждения "кто правее".

[quote]Идём ли мы последовательно или сразу пытаемся получить какое-то практическое решение. Попытки быстро перейти к реализациям ВПД мне кажутся очень очень преждевременными. Понятно, что хочется получить полезные практические результаты уже на начальной стадии, но лично у меня такой спешки нет и более того есть сильное понимание бессмысленности такого желания без наличия базовой архитектуры.[/quote]
К сожалению, при создании ИР получить быстрый результат не получится. Но, при этом, никто не запрещает использовать созданные наработки с своих проектах, в том числе и коммерческих. В общем-то в рамках проекта AIKernel можно попробовать создать какой-то готовый продукт. Однако, основные принципы AIKernel, должны быть обеспечены (а именно открытость разработок AIKernel).[/quote]




[quote="Prof1983"][quote="DCV"]Когда Вы сделаете сложное задание на MS C++ с использованием ООП, то будете говорить по-другому. Гораздо проблематичнее работать без ООП.[/quote]
Я согласен, что с ООП работать несколько проще. Но при попытке портирования или при попытке использовать чужие разработки в своей программе могут возникнуть непреодолимые препятствия. Зачастую проще переписать все с нуля, чем пытаться как-то использовать чужие разработки, созданные на другом ООП языке. С процедурными языками проблем в этом плане меньше. Поэтому, получается, что проблематичнее работать с ООП чем без. Кроме того, зачастую это и не требуется. Например, можно сделать что-то на подобие (абстрактный пример):
[code]type
  TAButton = packed record
    Color: TColor;
    Text: string;
    ...
  end;
  PAButton = ^TAButton; // Указатель на выделенный блок памяти
  function Button_SetText(Button: PAButton; const Value: string): Integer;
  function Button_Show(Button: PAButton): Integer;
  function Button_Hide(Button: PAButton): Integer;[/code]
или можно сделать обертки для классов
[code]type
  TAButton = class
  ...
  end;
  // Объект класса, по сути - это указатель выделенный блок памяти
  PAButton = Integer(TAButton);
  function Button_SetText(Button: PAButton; const Value: string): Integer;
  begin
    TAButton(Button).Text := Value;
  end;
  function Button_Show(Button: PAButton): Integer;
  begin
    Result := TAButton(Button).Show;
  end;
  function Button_Hide(Button: PAButton): Integer;
  begin
    Result := TAButton(Button).Hide;
  end;[/code]

Я думаю, что базовую часть и ядро системы нужно создавать на простом языке, а различные расширения и дополнения можно писать на других языках с применением разных технологий. В том числе, для сторонних модулей и программ, возможно использование виртуальных машин и т.п.[/quote]




[quote="Prof1983"][quote="vchc"]Вы поступаете методологически некорректно. Сначала создаёте какую-то реализацию без чётких требований к ней, то есть ваше ядро, а потом предполагаете, что эта структура будет кем-то для чего-то использоваться. Это прямой путь не туда )) Эту структуру прежде всего должны использовать мы сами для решения наших задач. Так вот пока задачи не описаны, структура не имеет ценности.[/quote]
Признаться меня удивили такие вопросы. Сейчас перечитал свои сообщения в этой ветке и понял, что описывая проект AIKernel нигде не написал главного. А именно вот что: я планирую проект AIKernel не как конечный продукт для пользователей, а лишь как "набор разработчика", toolkit, SDK. Это делается в первую очередь для того, чтобы разобраться самому в различных подходах и выделения общих вещей для различных подходов создания ИИ и ИР. Это "главное" и должно, по моему мнению, попасть в ядро ИИ системы и лечь в основу дальнейших разработок. При этом "модули" в AIKernel могут решать совершенно разные задачи, но должно быть что-то, что их объединит.

Лично мне, на данный момент, интересно было бы заняться CLIPS. Хочу научиться компилировать его в виде DLL с возможностью использования в качестве одного из "модулей". Это то, что интересует меня в данный момент. Каждый должен выбрать для себя что ему интересно. И заняться реализацией. Но, при этом, давать другим разработчикам возможность использования уже реализованного функционала. Иначе получится "еще один проект" реализации ИИ. Вместо того, чтобы кидаться реализовывать очередную программку, я предлагаю сначала определиться с правилами как нужно писать код, на каком языке, под какой лицензией, какие основные типы данных использовать и другие фундаментальные вопросы.

Лично для себя, в своих проектах, я боле или менее определится с этими вопросами. Теперь я пытаюсь понять правильный выбор я сделал или нет. Например я пришел к выводу, что в любом языке нужно стараться писать наименования типов, функций и переменных в виде, когда каждая первая буква пишется с большой буквы:[code]String; ToInteger; IsStatic; IntToStr;[/code]
Так же определил для себя базовые типы, которые не зависят от языка реализации:
[code]AInteger;AFloat;AString;AID;AVersion;[/code]
Это все может показаться совсем не важным на первый взгляд, но читать и разбираться в чужом коде, когда он написан абы как нет никакого удовольствия. А если мы говорим про совместную работу, то это придется делать постоянно. Но я не собираюсь навязывать свое мнение, т.к. сам точно не знаю как более правильно. Я думаю вопросы по базовым типам, принципам наименования типов, функций и переменных можно отложить на потом, а пока попробовать начать реализацию первого "модуля". Нужно только определиться с направлением, выбрать ту или иную технологию за основу разработки.

Как на счет заняться онтологиями? Я думаю эта тема будет интересна многим. В частности "модуль" онтологий, на мой взгляд, должен обеспечивать некоторый API для выборки, поиска и некоторой обработки классов, индивидов, и их связей (триплетов). "Модуль" онтологий может работать с какой-либо SQL БД или с XML файлом или хранить все данные в оперативной памяти.
Одновременно можно заняться реализацией "модулем" логического вывода онтологических знаний. Для минимальной функциональности и для работы с БЗ так же потребуется редактор знаний. Для этого можно начать еще один "модуль" - редактор онтологий, или принять какой-то существующий редактор.

За тем подготовить сборку, в которую будут входить данные "модули" в виде отдельных программ. И выпустить как готовый продукт.

Если вести реализацию в рамках проекта AIKernel, то брать проекты, реализованные с использованием виртуальных машин лучше не стоит. Однако можно попробовать переписать Java реализацию на С++ или на Delphi. Заодно разобраться какие классы приняты в том или ином проекте и почему, какие алгоритмы используются и т.д. Например, можно взять проект Jena и разобраться что там и как реализовано.[/quote]




[quote="victorst"]По моему (но только по моему субъективному) мнению, чистый С без OS API ориентации , был бы неплох. Если кому-то хочется, можно любые объекты на чистом С написать или взять готовые. С++ к сожалению не настолько платформонезависим, часто очень даже зависим. Тот же CLIPS со своими объектами написан на чистом С и может компилироваться под *Nix, Mac, Windows. Единственный язык, который по некоторым пунктам составляет конкуренцию - это Java. Но он в основном для серверов. А в быту его результаты плачевны - скорость из-за виртуальной машины никакая. Да и писать, например, нейронную сеть по обработке зрительных образов робота в реальном времени на Java - это особое извращение. И в матрицу ARM процессоров лучше С код запихивать, чем Dephi или Java.
А вот уже на чистом С изгородить движок для экспериментов по ИИ - это было бы весьма лепо. Если его оформить в виде dll обычной, то можно из почти любых языков юзать с помощью вызовов функци1 этой dll. Я даже кажется уже кое-что придумал на эту тему. Но еще пообмозгую.[/quote]




[quote="Prof1983"][quote="daner"]Простите, но разговор идет на уровне: Решили мы делать платформу для автомобиля, давайте давайте для начала договоримся какого цвета будет эта платформа.[/quote]Думаю, что разговор пока еще идет на уровне, когда нет даже решения о создании какой-либо платформы. Есть только общее желание что-то сделать, чтобы получить ИР. Но в какую сторону нужно двигаться - единого мнения пока нет.

[quote="daner"]Можно делать SDK, а можно делать платформу для интеграции различных решений. Если первое, то до того как решать на каком языке это все реализовывать, стоит решить, какие именно инструменты (почему и для чего) в этот SDK вообще будут входить. Если второе, то язык вообще дело десятое и начать стоит с протоколов взаимодействуя всевозможных модулей (хотя опять таки, начать стоит в первую очередь с того, какие модули вообще могут быть интегрированы).[/quote]
Лично я пытаюсь продумать базовый API, набор утилит, SDK и т.д. для широкого круга различных "модулей". Вообще хотелось бы разработать платформу для возможности присоединения абсолютно любых "модулей" которые потребуются или могут потребоваться для создания ИР. Пока собираю мнения разных людей по этому поводу.
На счет языка реализации, лично для себя я решил, что "модули" должны быть написаны на компилируемом языке. Какой именно будет язык (Си, C++, Pascal, Asm) - это уже не так важно. При этом, наверное, можно будет сделать так, чтобы "модуль" мог обращаться к каким-то внешним программам и сервисам, к внешним БД и хранилищам. А так же, при желании, можно будет в "модуль" запихнуть реализацию на интерпретируемом языке вместе с интерпретатором или виртуальной машиной (например JUA, JNI, Perl интерпретатор и др.). Главное обеспечить доступ к функционалу данного "модуля" для остальной системы.

Я вижу примерно такой минимальный базовый API (Pascal):
[code]function Runtime_Modules_AddModule(Module: AModule): AInteger;
function Runtime_Modules_DeleteModuleByIndex(Index: AInteger): AInteger;
function Runtime_Modules_DeleteModuleByName(const Name: AString): AInteger;
function Runtime_Modules_GetModuleByIndex(Index: AInteger; Module: AModule): AInteger;
function Runtime_Modules_GetModuleByName(const Name: AString; Module: AModule): AInteger;
function Runtime_Modules_InitModuleByName(const Name: AString): AInteger;
function Runtime_Init: AInteger;
function Runtime_Done: AInteger;
function Runtime_Run: AInteger;[/code]
Где AModule - это указатель на структуру, в которой записаны основные параметры, идентифицирующие модуль. Например так:
[code]type
  AModule = Pointer; // Указатель на AModuleRec
type
  AModuleRec = packed record // 8x4=32 bytes
    Version: AVersion; // Версия реализации модуля
    Name: AString; // Уникальное наименование модуля.
    Init: AInitProc; // Указатель на функцию, для инициализации модуля
    Done: ADoneProc; // Указатель на функцию, для завершения работы модуля
    Reserved04: AInteger; // Зарезервировано
    Reserved05: AInteger; // Зарезервировано
    Reserved06: AInteger; // Зарезервировано
    Reserved07: AInteger; // Зарезервировано
  end;[/code]
Для достижения уникальности наименования модуля, модуль можно именовать например так: "AIKernel.ExampleModule1" или "org.aikernel.example_module_1"

Функции получения информации о модуле записаны так[code]function Runtime_Modules_GetModuleByIndex(Index: AInteger; Module: AModule): AInteger;
function Runtime_Modules_GetModuleByName(const Name: AString; Module: AModule): AInteger;[/code]а не так[code]function Runtime_Modules_GetModuleByIndex(Index: AInteger): AModule;
function Runtime_Modules_GetModuleByName(const Name: AString): AModule;[/code]для того, чтобы не передавать информацию копированием и, таким образом, не давать возможности ее испортить (заменить наименование модуля и др).[/quote]




[quote="Prof1983"][quote="vchc"]Прошу высказываться.
Конечно стоит ещё посмотреть, что есть в этой области уже из готовых решений и не будем ли мы изобретать велосипед.[/quote]
Именно. Например, по моему, стоит сначала изучить OpenCyc, Jena, Proteje и другие подобные проекты прежде, чем изобретать свой велосипед.

[quote="vchc"]Что касается соглашений по оформлению кода, то это зависит от платформы и языка. В c++ уже есть стандартные схемы. Как и в .Net и я думаю в других языках.[/quote]
Нужно, по хорошему, выработать единый формат наименования типов, процедур и функций, который бы не зависел от конкретного языка реализации. Хотя я не читал стандарты MSDN на этот счет, но мне нравится подход Microsoft в этом вопросе.[/quote]




[quote="Prof1983"][quote="daner"]использование gcc ТОЧНО не создает никаких проблем с лицензированием программ (примеров коммерческого софта компилированного на gcc -- море, здесь нечего выдумывать). Я даже не понимаю откуда вы придумали эти ограничения на статическую компиляцию. Все что вы должны сделать, это (цитирую): [i]Если вы связываете с библиотекой другое программное обеспечение, вы обязаны предоставить новым обладателям библиотеки все файлы данного программного обеспечения в виде [b]объектного кода[/b].[/i]

все эти требования к *.о файлам (из за которых вы предпочитаете С)... ИМХО просто надуманны.
С (лично для меня) слишком примитивен. Не поддерживаются ставшие уже стандартом парадигмы (т.е. использовать их конечно можно -- но это извращение), такие как например ООП. С# -- отпадает (лично для меня) из-за не мульти-платформенности (ну если не учитывать MONO, который пока застрял на достаточно старой версии С#), а Java из-за гемаройной работы с DLL (.so) файлами (ну и скорости выполнения конечно). Так что, остается именно С++ (конечно, с какими-нибудь библиотеками типа GTK+, Qt, boost, MFC и т.д.). Но вообще, хозяин - барин. Какой лично вам язык больше нравится, такой и выбирать надо, на любые проблемы с языком -- всегда можно найти какое-нибудь решение.[/quote]

Вот тут встретил подтверждение моим словам: http://itgator.ru/2010/04/17/bsdelniki-clangbsd-sobiraet-sebya/
[quote]Как известно, FreeBSD до сих пор использует GCC версии 4.2.1, т.к. последующие версии сменили лицензию.[/quote]
И еще. Раньше Apple для компиляции iOS использовала GCC. Сейчас они используют LLVM.
http://developer.apple.com/xcode/[/quote]




[quote="Prof1983"]Лично меня сейчас больше интересует программный код реализации, чем наполнение какими-то конкретными знаниями. Вообще планирую сначала сделать обзор существующих разработок в области ИИ.
[quote="DCV"]6. Разработать программный модуль для хранения и обработки этих данных.
Должна быть возможность использовать созданный программный модуль в различных проектах и разработках.[/quote]Как именно планируется реализовывать? На каком языке программирования? Какую систему планируется взять за основу? Проводили анализ существующих разработок по этой теме или нет? Если да, то "ссылку в студию". :)[/quote]




[quote="Prof1983"][quote="Dimmy"]один я заметил что прошло полгода с момента первого сообщения?
каков прогресс?[/quote]Проект не коммерческий, поэтому занимаюсь им в свободное время. Достижений очень не много и они довольно примитивные. Если быть точнее, то достижение в общем-то только одно - создан сайт aikernel.org, и идет его наполнение информацией.

Основные выполненные работы:
1. Написан предварительный вариант манифеста для проекта (http://aikernel.org/develop/manifesto/index.ru.html)
2. Провел анализ лицензионных ограничений на разработки и выбрал лицензию для проекта AIKernel (http://aikernel.org/develop/license/index.ru.html)
3. Идет наполнение сайта в целом и в частности один из основных разделов сейчас - это раздел "ИИ - Проекты" (http://aikernel.org/ai/projects/index.ru.html) - провожу анализ существующих проектов и разработок в области ИИ.
4. Разгребаю потихоньку залежи файлов на своем компьютере. Пытаюсь сгруппировать, структурировать разрозненные клочки информации. В частности выложил информацию по проекту AIAssistant (http://aikernel.org/projects/aiassistant/index.ru.html) и готовлюсь выложить информацию по своему давнему проекту AR (http://aikernel.org/projects/ar/index.ru.html).
5. Параллельно занимаюсь изучением Си и C++.

Работа по проекту AIKernel идет очень медленно, но я пока никуда не тороплюсь. За годы изучения ИИ, да и вообще жизни, я пришел к выводу, что лучше делать работу качественно, чем быстро и много. Я, пожалуй лучше, буду писать по одной маленькой страничке или по несколько строк кода в день. Но, при этом, делать работу так чтобы, не дай бог, не пришлось что-то переделывать (особенно это важно для "ядра" и всего, что с ним связано). А так же стараюсь чтобы сделанная работа была частью единого и мощного проекта, а не разрозненными разработками, которые не возможно использовать совместно.[/quote]




[quote="victorst"][quote="Prof1983"]За годы изучения ИИ, да и вообще жизни, я пришел к выводу, что лучше делать работу качественно, чем быстро и много. Я, пожалуй лучше, буду писать по одной маленькой страничке или по несколько строк кода в день. Но, при этом, делать работу так чтобы, не дай бог, не пришлось что-то переделывать (особенно это важно для "ядра" и всего, что с ним связано.[/quote]Мой опыт говорит о том, что если сильно-сильно сосредоточиться на частностях или даже на главностях, и очень потихоньку это делать, то все равно абсолютно не застрахован от попадания в очередной тупик. Мой путь - это блуждание в лабиринте. Но часто оказывается, что он - лишь подлабиринт большого лабиринта. Поэтому я решил никаких длительных теоретических работ не затевать, а пробовать реализовать несколько практических дел в области ИИ. Но т.к. их одновременно не осилить, то делаю одно дело до тех пор, пока оно не замучает меня. Затем перехожу к другому. И т.д. по кругу. Круг состоит из 3- 5 проектов. Это хождение по кругу, а точнее по какой-то спирали. С каждым возвратом к очередному делу я в нем продвигаюсь вперед или куда-то вбок, но тоже как бы вперед. Отвлечение от дела позволяет взглянуть на него как-бы издалека, вновь переаргументировать его необходимость для единого ИИ строения и вернуться к нему, наполнив новыми идеями.[/quote]




[quote="Prof1983"][quote="victorst"]Это хождение по кругу, а точнее по какой-то спирали.[/quote]У меня аналогичная ситуация. Постоянно меняются мысли как можно попробовать реализовать ИР. Но две вещи остается неизменными:
1. Нужно всю работу делать в виде маленьких стабильно работающих "модулей" (программ, утилит, библиотек, функций, алгоритмов);
2. Все данные информацию и знания лучше преводить к единому виду. А именно обрабатывать и хранить в виде "сущностей" (массив байтов с указанием типа данных для обработки и с назначением уникального идентификатора для каждой сущности).

[quote="DCV"]Это идея, которая появилась в данный момент. Похожую работу я описывал тут в первом сообщении: viewtopic.php?f=96&t=2085&start=180
Другой информации по теме у меня нет. Меня не волнует способ реализации, потому что это дело техники. Если найдутся желающие наполнять картотеку и подготовят начальный материал, то я могу сделать программу и отдать для общего проекта.[/quote]Идея наполнения более или менее понятна. Меня интересует, в основном программная реализация. Я все-таки повторю вопросы с уточнением: На каком языке программирования [b]планируется реализовать программу[/b]? Какую систему планируется взять за основу? Проводили анализ существующих разработок по этой теме или нет? И еще предложение (или даже просьба): Сделайте описание вашего проекта в виде статьи или документации. Это можно сделать вырезками сообщений с форума с необходимой корректировкой.[/quote]




[quote="Prof1983"]Перенесено из ветки "Проект Neuronium" http://ai.obrazec.ru/forum/viewtopic.php?t=2316

Сегодня, на работе, в очередной раз всплыл вопрос про базу нормативной документации. Решали как сделать так, чтобы можно было удобно пользоваться документацией, хранить в одном месте. А так же было бы не плохо сделать поиск по ключевым словам (по тегам) и, желательно, по смыслу. Планирую сделать хранение данных в виде отдельных параграфов в которые могут включаться картинки, формулы, ссылки, файлы и пр. Хочу попробовать использовать для хранения такой информации БД в виде сущностей. На выходных планирую начать делать небольшую программку для первичного наполнения БД. Саму программу планирую делать в рамках проекта AIKernel, а сама нормативная база будет, наверное, распространяться на коммерческой основе.
[quote]Важность смыслового представления деловой документации огромна.
Я представляю это так. Пользователь собирается написать новый документ. Письмо, инструкцию и т.д. Он может взять специальную программу, в которю вводит текст. Этот текст интерактивно программа немедленно переводит во фрагмент единой онтологии предприятия. С этого момента документ может понимать не только получатель- человек, но и специальный программный агент, который легко может им пользоваться.[/quote]Да. Можно углубляться и переводить все документы в онтологический вид, но в данном случае идет о нескольких десятков файлов которые нужно, для начала, разложить на крупные составляющие - на главы и параграфы. Это, пока что, будет атомарной единицей информации. Каждой такой единицей нужно назначить ключевые слова для быстрого поиска. На следующих этапах, при необходимости, можно будет разложить параграфы на абзацы, картинки, формулы и другие составляющие. Потом, в будущем, можно будет даже разложить всю информацию на "понятия" и записать их в виде триплетов.

И так назову программу DocumAssistant. Программа будет создаваться в рамках проекта AIKernel и на основе наработок программы Assistant (http://www.assembla.com/spaces/assistant/). Какую базу данных выбрать пока не принял решение. Пожалуй, для доступа к данным и информации придется разработать универсальный интерфейс (набор функций), который не будет зависеть от какого-либо вида доступа к данным. В дальнейшем, скорее всего, нужно будет воспользоваться какой-либо СУБД. Пока, наверное, буду сохранять всю информацию в виде простого бинарного файла собственной структуры. Разработка программы будет вестись на Pascal (Delphi, Lazarus/FreePascal), с возможностью подключения сторонних "модулей" (библиотек, плагинов, утилит, программ, СУБД), написанных на других языках. Приглашаю желающих поработать вместе.[/quote]





[quote="victorst"]Документно-ориентированные поисковые системы и онтологические базы знаний отличаются настолько же друг от друга как искусственный нейрон и персептроны на их основе от мозга человека, или как транзистор и радиоприемник на транзисторах от современного CPU на основе аналогичных транзисторов. Приблизительно так. Можно сколько угодно признаков поиска делать, но если не разложить каждый документ, каждое слово и букву в этом документе на смысловые единицы и не увязать их в единую онтологию - особого смысла в документах не найти, процессы работы с документами в полной мере не автоматизировать. И не только слова и буквы разложить, а самое главное - смысл, стоящий за текстом. Например, если говорится о шахтах, то программа должна это понятие, попавшееся в тексте идентифицировать в онтологии в том месте, где описывается шахта и ее свойства. В общем - нужно различать понятие "Слово шахта" и понятие "Шахта". В моем случае они хранятся в разных онтологиях. Первое - WordNet, второе - в SUMO. И эти онтологии связаны между собой.
Очевидно, что без применения какой-нибудь экспертной системы не обойтись. По хорошему - все нормативные документы должны быть преобразованы в свод- онтологию правил а все поднормативные документы при создании должны сразу сверяться с нормативной базой. Тогда законодательных коллизий будет меньше. Но это же все нужно "лопатить", кто же это будет делать? Я имею ввиду прежде всего уже имеющуюся нормативную базу. Возможно - эксперт или экспертная программа под управлением эксперта. Только похоже, государству дела нет до такого упорядочивания. Я уже несколько раз посылал нашему президенту письмеца с предложением о начале строительства "Государственной машины" на основе онтологии и онтологических интеллектуальных агентов- заменителей чиновников. Приняли к сведению. Отписка, отмазка. Мдяя.
Я уверен, что создание такого рода "Государственной машины" неизбежно. Она будет создана даже в планетарном маштабе. Но это сколько же еще всяких бесполезных и несвязанных между собой баз данных еще понаделают, сколько в землю денег зароют. База ГАИ, пенсионного фонда и т.д. Путин недавно сказал "нужно обмениваться базами данных" не помню кого с кем. Но это как совместить несовместимое. Я написал в блог президента по поводу единых карточек, что сначала нужно такую онтологию - единое досье на все и вся завести, а потом добавлять идентификационные свойства - карточки, отпечатки, зрачки, ДНК к одному единому понятию - "Иван Пупкин". Забанили... Эх, Россея...
Однако меня что-то далеко от темы занесло. Можете стереть лишнее.[/quote]




[quote="Prof1983"][quote="victorst"]Однако меня что-то далеко от темы занесло. Можете стереть лишнее.[/quote]Стирать чужие сообщения, на сколько мне известно, я не могу. Да и не в моих правилах что-то удалять из истории. "Слово - не воробей, вылетит - не поймаешь". Я считаю, что не нужно извиняться за свои слова или сожалеть о своих поступках. Вместо этого, нужно стараться заранее продумать последствия на перед. Но это к теме не относится.

То что касается программы DocumAssistant, то онтологии пока в ней не будет. А будет простейшая БД различной информации: параграфов из нормативной документации, разделов, картинок, файлов и т.п. Объять необъятное не получится. Я не смогу пока перевести нормативную документацию в онтологический вид - это очевидно. Но сделать хранение разрозненной информации в едином месте - довольно легко решаемая задача.[/quote]




[quote="Prof1983"][quote="Prof1983"]сделать хранение разрозненной информации в едином месте - довольно легко решаемая задача.[/quote]Оказалось, что создать даже простое описание метаданных хранимых в БД элементов (сущностей) - это довольно сложная задача. Я решил поискать какое-нибудь подходящее готовое решение (БД). Сделал микрообзор свободных СУБД.

В итоге со свободными (BSD подобными лиценциями)  смог найти только следущие
[quote][b]BSD License[/b]

    [b]PostgreSQL[/b]
    postgresql.org
    http://ru.wikipedia.org/wiki/PostgreSQL
    [b]SQLite[/b] - Лицензия Общественное достояние
    http://ru.wikipedia.org/wiki/SQLite
    sqlite.org
    [b]CUBRID[/b] (License: Server - GPL, API - BSD)
    http://ru.wikipedia.org/wiki/CUBRID
    [b]C-Store[/b] - ориентированная на хранение записей по столбцам
    http://ru.wikipedia.org/wiki/C-Store

[b]Apache/MPL License[/b]

    [b]Firebird[/b] (Лицензия IDPL, InterBase Public License, Mozilla Public License 1.1) (C++)
    http://ru.wikipedia.org/wiki/Firebird
    http://ru.wikipedia.org/wiki/Firebird_%28database_server%29
    [b]Apache Derby[/b] (Java)
    http://ru.wikipedia.org/wiki/Apache_Derby
    [b]Sedna[/b] (XML)
    http://ru.wikipedia.org/wiki/Sedna
[/quote]
Еще есть такие СУБД (под ограниченно свободной лицензией GPL. то есть без возможности использовать в закрытых проектах):
[quote][b]GPL[/b]

    [b]MySQL[/b]
    Berkeley DB - Лицензия Sleepycat License (Совместима с GPL)
    http://ru.wikipedia.org/wiki/Berkeley_DB
    [b]Ingres[/b]
    http://ru.wikipedia.org/wiki/Ingres
    [b]OpenOffice.org Base[/b] (LGPL)
    http://ru.wikipedia.org/wiki/OpenOffice.org_Base
    [b]FramerD[/b] (GNU GPL)
    framerd.org
[/quote]
http://aikernel.org/develop/instruments/index.ru.html

Пришел к выводу, что нужно либо смотреть в сторону PostgreeSQL, или SQLite, или писать свою, похожую на FramerD или искать дальше. Наверняка в сети есть еще разработки на базе которых можно создать универсальное хранилище данных.[/quote]




[quote="Prof1983"][quote="gsvano"]На сколько я помню PostgreSQL умела работать с объектами, в том числе и связанными. А так же она неплохо кластеризуема, если я ничего не путаю. IMHO хороший выбор.[/quote]Скорее всего так и есть. СУБД довольно широко используемая. Третья по популярности из свободных СУБД.
Скачал исходники, посмотрел их - естественно ничего не понял. :) Нужно найти хорошую книжку или документацию. Займусь этим как-нибудь в свободное время. Жаль времени свободного почти нет.

А вообще надо бы сделать более подробный обзор СУБД. Может кто знает, какие еще есть проекты (СУБД) для хранения различных данных (в виде блоков данных, не реляционные, не SQL)?[/quote]





[quote="victorst"]Простое хранилище ключ-значение (key-value) запросто можно сделать на Делфи. В книжке я нашел и проверил очень неплохой пример со всеми исходниками. Стандартное B+Tree или даже B++Tree. Лучше всяких чужих SQL и других БД. И главное- все предельно понятно в ней - что и как работает. Если нужно - скину материальчик. А м.б. он у вас уже есть. Я и сам к такому решению склоняюсь. Не люблю семиэтажные этажерки в доступе к SQL.
Если покопаться в глубине БД, то увидим, что всякие ключи и индексы там - это тоже (key-value) деревья, только размазанные по одному общему файлу БД или даже в отдельных индексных файлах хранятся. Развитие БД привело к тому, что стали они неповоротливыми монстрами.[/quote]




[quote="Prof1983"][quote="victorst"]Мне нравятся хранилища ключ-значение (key-value).[/quote]Я как-раз и ищу такую готовую СУБД.
Посмотрел Tokyo Cabinet. Очень заинтересовало. Вот их сайты:
http://fallabs.com/
http://1978th.net/
Вот тут обсуждение небольшое есть: http://www.sql.ru/forum/actualthread.aspx?tid=713971
Все бы хорошо, но вот лицензия Tokyo Cabinet: GNU General Public License (GPL) and GNU Lesser General Public License (LGPL), но можно и коммерческую приобрести (12,000 US dollars). http://fallabs.com/license/

Надо подумать, поизучать, может все-таки найдется СУБД key-value под BSD или Appache/MPL.[/quote]




[quote="Prof1983"][quote="vchc"]Можно ещё сюда сходить [url]http://www.db4o.com/[/url][/quote]Не очень мне нравится идея использовать СУБД использующую (написанную) на Java и DotNET.

Вчера обнаружил небольшую key-value СУБД под DSB license: [b]Redis[/b]
http://redis.io/ - Сайт проекта
http://code.google.com/p/redis/
http://no-sql.ru/viewforum.php?f=19 - Источник, где я нашел эту "Редис". :)

Написана СУБД на Си. Хочу попробовать скомпилировать под Windows. Описание по компиляции, вроде, есть вот тут http://no-sql.ru/viewtopic.php?f=19&t=15[/quote]




[quote="Prof1983"]Сделал микро обзор свободных компиляторов, которые хорошо подойдут для проекта AIKernel. Основная проблема в выборе компилятора - это лицензионные ограничения. Очень много открытых проектов (и в том числе компиляторов) распространяются под лицензией GPL. GPLv3 накладывает существенные ограничения на использование в проектах, распространяющихся под не GPL лицензией. В общем-то мне удалось обнаружить всего два подходящих компилятора: Clang и PCC.
[quote][b]Clang (BSD)[/b]
http://ru.wikipedia.org/wiki/Clang
http://clang.llvm.org/
[b]Portable C Compiler (BSD)[/b]
http://ru.wikipedia.org/wiki/Portable_C_Compiler
http://pcc.ludd.ltu.se/
[b]GNU Compiler Collection (GPL)[/b]
http://ru.wikipedia.org/wiki/GNU_Compiler_Collection
[b]Tiny C Compiler (GPL)[/b]
http://ru.wikipedia.org/wiki/Tiny_C_Compiler
[b]Free Pascal (GPL)[/b]
http://ru.wikipedia.org/wiki/Free_Pascal[/quote]
Источник: http://aikernel.org/develop/instruments/index.ru.html[/quote]




[quote="Prof1983"][quote="daner"]Все что производит GPL программа не подпадает под GPL лицензию (это прямо конкретно где-то у них на сайте написано).[/quote]Почему-же FreeBSD, OpenBSD и остальные, а так же Apple сидят на GCC 4.2.1 и, судя по активности, стараются как можно быстрее перейти на Clang? Хотя Clang создает менее эффективный код и некоторые тесты все еще не проходят. Проблема в GPLv3, на мой взгляд, в двух вещах: это невозможность легальной статической компиляции lib (.a) файлов и использование файлов заголовков (.h) в не GPL программах. Ведь .h - это тоже исходный код! И, при компиляции, этот исходный код (GPL) будет использоваться в компилируемой программе.
[quote="daner"]Если я не ошибаюсь, то даже с плагинами проблем нет.[/quote]Проблем с плагинами нет. Исполняемая GPL программа может использовать как открытые, так и закрытые функции и библиотеки. Существует много GPL программ в Windows, которые используют проприетарный Windows API, ядро Linux использует проприетарные драйвера и прошивки - это все вполне законно.

Кстати. Популярная IDE Eclipse строится по принципу маленького загрузчика с открытым (свободным) исходным кодом. А некоторые плагины, входящие в Eclipse распространяются под другими лицензиями (в том числе проприетарными).

Есть вариант написания программ, как небольшого исполняемого файла (загрузчика) под GPL с плагинами под другими лицензиями. В общем, для себя лично и для проекта AIKernel будет лучше использовать компоненты (в том числе компиляторы) под BSD подобными, MIT, MPL и Apache лицензиями. Компоненты под GPL лучше не использовать. Допускается использование GPLv3 компонентов только если нет свободных аналогов, или для отдельных утилит, не компилируемых совместно с основными исполняемыми файлами.[/quote]




[quote="Prof1983"]Решил выложить на общее обозрение DocumAssistant. Программа пока ничего не делает. Выкладываю в качестве отчета о проделанной работе и для обсуждения архитектуры построения программы.

Архитектура такая: Runtime + модули. Где модули - это набор реализованных функций, которые располагаются или в составе основной программы (монолит) или в отдельных библиотеках (DLL, плагинах).

Вот небольшое описание:
[quote]Программа DocumAssistant написана на языке ObjectPascal в среде Delphi 7.
Пока что поддерживается компиляция только в Delphi 7.
После небольших доработок есть возможность компиляции на Lazarus (FreePascal) или на других версиях Delphi.

Центральной частью программы является Runtime в котором регистрируются различные модули.
Каждый модуль содержит определенный набор функций.
Модуль может быть в составе основной программы (EXE), а так же может быть вынесен отдельную библиотеку (DLL, плагин).

-- Содержимое DocumAssistant --
Bin - Скомпилированные бинарные файлы
Source - Исходные тексты для компиляции
Temp - Временные файлы. Используется при компиляции

Archive.bat - добавляет всю директорию в архив 7z
Clear.bat - очищает Temp от временных файлов
Dirinfo.txt - этот файл
License.en.txt - лицензия на программу и исходные тексты на английском языке (BSD)
License.ru.txt - лицензия на программу и исходные тексты на русском языке (BSD)
Version.txt - записана версия программы


-- Содержимое Bin --
Data - различные файлы, необходимые для работы программы

Example.adb - пример БД
DocumAssistant_Monolit.exe - выполняемый файл программы


-- Содержимое Source --
Common - Общие файлы, не привязанные к какому-либо модулю
Modules - Отдельные модули программы (включая Runtime)
Projects - Файлы проекта (DocumAssistant_Monolit.dpr)


-- Содержимое Modules --
Documents - содержит функции работы документами, как с высокоуровневыми объектами. Работает с модулем Entities.
DocumUI - интерфейс пользователя программы DocumAssistant
Entities - функции для работы с БД сущностей
Plugins - использования плагинов
Runtime - содержит в себе список подключенных модулей и функции доступа к модулям. Runtime не является модулем, а является центральной точкой подключения модулей.
Settings - функции работы с настройками (INI файл, реестр).
System - основные системные функции
UI - графический интерфейс пользователя (используется VCL/LCL)
UISettings - содержит интерфейс пользователя для доступа к настройкам (окно настроек)
UISplash - всплывающее окно, отображаемое при запуске программы
UIWorkbench - рабочее пространство (надстройка над UI)
Utils - различные утилитные функции (SysUtils)

- Файлы с перечислением функций модулей (аналоги .h файлов в Си, но с динамическим назначением адресов функций) -
AEntities0.pas
APlugins0.pas
ARuntime0.pas
ASettings0.pas
ASystem0.pas
AUI0.pas
AUISettings0.pas
AUIWorkbench0.pas
AUtils0.pas[/quote]
Тут расположил страничку проекта DocumAssistant: http://aikernel.org/projects/documassistant/index.ru.html
Вот сама программа: http://aikernel.org/files/documassistant.zip[/quote]




[quote="Prof1983"]Написал свой ответ на вопросы, касающиеся AIAssistant, а так же касающиеся AIKernel тут:
http://ai.obrazec.ru/forum/viewtopic.php?p=28837#p28837[/quote]




[quote="Prof1983"]У меня возникло несколько вопросов, касающихся программной реализации проекта AIKernel. В частности:
[list][*]В каком виде лучше передавать строки, как параметры функций (PChar/char*, string(class), string(массив Delphi + доп.пред.инфо))?
[*]Какой метод вызова выбрать для функций внешних и внутренних модулей (fastcall, cdecl, stdcall, pascal, safecall)?[/list]

Эти вопросы я уже рассмотрел, но не до конца уверен в правильности своего выбора. Поэтому нужен совет опытных программистов. По моему будет не очень хорошо обсуждать технические вопросы в общей куче с общими вопросами, касающимися философии AIKernel. Отсюда возникает вопрос: в каком разделе лучше задавать подобные вопросы? Или может быть с такими вопросами лучше обращаться на форумы для программистов?[/quote]




[quote="Prof1983"]Решил, что разводить обсуждение технических вопросов в этой ветке не стоит. Поэтому создал отдельные ветки для каждого вопроса вот здесь:
http://www.project-ai.org/forum/viewtopic.php?t=6 - Передача строковых параметров
http://www.project-ai.org/forum/viewtopic.php?t=7 - Выбор метода вызова процедур

To DCV:
1. Мой вопрос не про C#.
2. Передача разными методами существует не для поддержки старых методов вызова или для совместимости со старыми программами. А каждый из них имеет свои особенности (достоинства и недостатки).
3. Мой вам совет: расширяйте кругозор, прочитайте хотя бы одну книжку по компилируемым языкам программирования, не зацикливайтесь на C#. C# хороший язык, и .NET хорошая технология, но она, как и остальные имеет свою область применения.[/quote]




[quote="Василий"][quote="Prof1983"]Решил, что разводить обсуждение технических вопросов в этой ветке не стоит. Поэтому создал отдельные ветки для каждого вопроса вот здесь:
http://www.project-ai.org/forum/viewtopic.php?t=6 - Передача строковых параметров
http://www.project-ai.org/forum/viewtopic.php?t=7 - Выбор метода вызова процедур
[/quote]

Нарушение правил моего форума. Готов создать раздел специально для Вас и выдать права модерации.

Ссылки на Ваш форум прошу удалить добровольно.

[url=http://ai.obrazec.ru/forum/viewforum.php?f=125]Раздел[/url] создал, права Вам выдал.[/quote]




[quote="Василий"]Пока что не нормально. Я рад что Вы объединяетесь. Это правильно.

Но рекламировать эти объединения я не буду.

Ещё раз прошу использовать созданный для Вас раздел и убрать ссылки на посторонние сайты с форумами.

Правила форума: http://ai.obrazec.ru/forum/viewtopic.php?f=104&t=1246[/quote]

Не знаю где мне писать ответ - поэтому пишу здесь. Обычно обсуждение действий нарушителей, пользователей, модераторов и т.п. ведется в отдельной теме.

Теперь все понятно. Когда я регистрировался правила вроде бы были несколько иными, после этого я их не перечитывал. Лучше прикрепить правила форума вверху списка новостей.

Мои нарушения, на сколько я понимаю такие:
[quote]4. Никакие инициативы, подразумевающие объединение пользователей вне рамок форума, не могут быть опубликованы без согласования с владельцем ресурса.[/quote]
Кроме этого:
[quote]3. Владелец ресурса имеет преимущественное право принимать единолично любые решения.
[b]Правила для размещения рекламы и ссылок на другие ресурсы:[/b]
1. Любая ссылка на внешний ресурс должна быть согласована с администратором.
2. До одобрения Советом Администраторов любые ссылки на внешние ресурсы запрещены.
3. Пользователи, нарушившие этот раздел правил, могут быть удалены с форума без предупреждения.
[b]Правила для всех:[/b]
0. Регулярно читать правила и неукоснительно их выполнять.
[/quote]

Кроме этого:
[quote][b]Организационные правила работы форума[/b]
1. Все существенные решения принимаются Советом Администраторов.
2. Совет Администраторов проводится 1 раз в месяц 9го числа, - для находящихся в Санкт-Петербурге возможна очная встреча, для остальных доступны любые средства связи (ICQ, Skype, телефон).[/quote]
Могу ли я попросить, на следующем совете администраторов рассмотреть попрос о возможности разрешить мне указывать ссылки на свой проект AIKernel, а так же на связанные с ним подпроекты и обсуждения?




