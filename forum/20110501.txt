[quote]использование gcc ТОЧНО не создает никаких проблем с лицензированием программ[/quote]
Сейчас попробовал поискать зачем развивают компиляторы под BSD, если есть готовый GCC. Ответа не нашел. Получается PCC "еще один велосипед". Тем более, не понятно зачем нужен PCC, если уже есть компиляторы под BSD такие как clang.
Скорее всего никаких проблем в использовании GCC при компиляции проприетарных программ нет, но вопрос остается открытым: "зачем столько компиляторов под BSD, если уже есть GCC под GPL"?

[quote]MONO, который пока застрял на достаточно старой версии С#[/quote]
MONO застрял, по моему, из-за лицензионных ограничений на реализацию классов из MS .NET Framework. Об этом Столлман писал в одном из своих обращений.

[quote]Так что, остается именно С++[/quote]
В общем-то наверное да. С++ сейчас самый популярный и продвинутый язык с поддержкой использования разных парадигм программирования. Однако я в своих проектах стараюсь использовать простое процедурное программирование, а не лепить объекты везде где это где это нужно и не нужно. В частности, те объекты, которые ни от кого не наследуются и которые никто не наследует не стоит записывать в виде классов.

Например такой класс (Delphi, Object Pascal):
[code]type
  TExampleClass = class
  private
    FProp1: Integer;
    FProp2: string;
  public
    procedure ExampleProc;
  end;
  ...
procedure TExampleClass.ExampleProc;
begin
  ...
end;[/code]
   
можно записать так

[code]type
  PExampleRec = ^TExampleRec;
  TExampleRec = record
    Prop1: Integer;
    Prop2: string;
  end;
...
procedure Example_ExampleProc(Obj: PExampleRec);
begin
...
end;[/code]

Разницы в быстродействии, функциональности и т.д. - никакой. Зато, скомпилированные .o файлы можно относительно легко использовать в программе на другом языке.







[quote="DCV"]...похож на онтологию Лената, и это тупиковый подход для ИИ.[/quote]
Я не думаю, что это тупиковый подход.

[quote="DCV"]Человек использует язык для передачи информации, но не для хранения информации в мозге.[/quote]
Как именно и в каком виде происходит хранение и обработка данных и знаний в мозге человека до сих пор еще не ясно. Но в общем-то это не важно. Живой мозг и компьютер работают по разному, поэтому вид хранения информации и алгоритмы обработки этой информации, скорее всего, будут совершенно разными. При этом вид представления информации и вид хранения информации - несколько разные вещи. Ту же онтологию можно записать в текстовый файл, в XML виде, в БД в виде приплетов и др. При этом представление информации в виде графа - это тоже один из видов записи. Онтологию можно записать (или нарисовать) и в виде графа тоже.

[quote="DCV"]Я не знаю о визуальном редакторе Protege. Думаю, всем будет интересно, если Вы о нем расскажите или дадите ссылки в интернете.[/quote]
Вот ссылки из запроса из ya.ru:
http://protege.stanford.edu/
http://ru.wikipedia.org/wiki/Protege
Вот красивая картинка отображения онтологии (OWL) в графическом виде (в виде графа):
http://protege.stanford.edu/plugins/owl/images/OWLViz-BackpackersDestination.png

Читайте, изучайте. Я сам лишь поверхностно знаком с Protege.

[quote="DCV"]Язык беседы не должен совпадать с ЕЯ, но должен быть близким к ЕЯ.[/quote]
Этот вопрос у меня тоже не раз возникал. Я пришел к выводу, что нужно для начала использовать что-то на подобие Simple English или Basic English для общения с программой.

[quote]Бе?йсик-и?нглиш[1] (англ. Basic English — базовый английский) — международный искусственный язык на основе английского языка, созданный в 1925 году британским лингвистом Чарльзом Огденом.
Основное отличие от английского языка — сокращённый словарь (850 слов). Английская грамматика в бейсик-инглиш осталась в основном без изменений.
Бейсик-инглиш схож с Simple English, на котором существует отдельный раздел Википедии[/quote]
http://ru.wikipedia.org/

Написать общение на ЕЯ с использованием Simple English или Basic English намного проще, чем с использованием русского ЕЯ. Виктор пробовал создать свой язык для общения - BABYLON, за тем ECLIPSE. Но ECLIPSE стал, по сути, языком записи интерпретируемых скриптов для AIAssistant.

[quote="DCV"]Классы, созданные на одном языке MS Visual Studio, успешно могут использоваться на других языках MS Visual Studio. А работа без ООП над таким сложным проектом просто невозможна.[/quote]
Не путайте теплое с мягким. В MS Visual Studio используется только C++. Я же говорю об использовании разных языков: Си, Perl, Python, Rubi, Pascal и т.д. Классы, в разных языках имеют разное внутреннее представление. Из-за этого скомпилированные промежуточные классы, написанные на одном языке, очень трудно использовать в программах на других языках.

[quote="DCV"]C# требует CLR (Common Language Runtime) среда выполнения. Устанавливается при установке .Net Framework, которую можно бесплатно скачать с сайта Microsoft.[/quote]
Лично я стараюсь придерживаться принципа, чтобы программа могла компилироваться и работать на любом оборудовании и на любой платформе. Например программы на Си могут (теоретически) быть скомпилированы для использования в микроконтроллере какого-нибудь примитивного робота, а использование других языков будет проблематичным. Аналогично нет никакого смысла реализовывать CLI виртуальную машину или JVM для использования в маломощных устройствах.

[quote="DCV"]Мне сказали, что Java работает медленней, поэтому лучше не использовать из-за низкой производительности.[/quote]
Java медленее по сравнению с чем? Если сравнивать с плохо написанной программой на Си или C++, то разницы, скорее всего, не заметите. Если сравнивать с .NET, то Java работает так же. Если сравнивать с Mono, то в Linux ядре есть такая штука как JIT - она позволяет выполнять байт-код Java почти так же быстро как и нативные приложения. Поэтому использовать Java на Linux предпочтительнее, чем Mono.

[quote="DCV"]Какие есть компиляторы чистого C? И какие возможности у чистого C?[/quote]
Компиляторов очень много. Существуют компиляторы практически под любую платформу и для любого оборудования.
Для обычных приложений можно использовать любой C++ компилятор (например MS Visual Studio в Windows).

[quote="DCV"]...лучше использовать бесплатный C, и бесплатные библиотеки. А возможно, лучше купить один лицензионный компилятор MS C++ или MS C#...[/quote]
И еще раз не путайте теплое с мягким. Язык и компилятор - это разные вещи.





http://ai.obrazec.ru/forum/viewtopic.php?f=40&t=2168&p=28652#p28652

Еще хочу отметить про виды представления и записи информации и знаний в компьютере.

[b]Базовый вид представления информации[/b]

Если попытаться посмотреть на все виды представления информации, то можно прийти к выводу, что в компьютере вся информация хранится и передается в виде последовательности байтов разной длины. Отсюда следует вывод, что базовым видом представления информации и знаний можно (и нужно) принять именно последовательность байтов. Другими словами, любую информацию и любые знания можно записать в виде массивов байтов.

По сути такие последовательности байтов, в ОС - это есть файлы. Аналогично во всех основных СУБД запись данных производится аналогично - в виде блоков в которых находятся некоторые данные. Это реализовано и в MySQL и в Firebird и в DB2. Реляционный же вид представления данных или другой в БД, в свою очередь, является внешней оболочкой для внутреннего движка БД.

У каждого такого блока в файловой системе ОС есть уникальное имя (путь), внутри БД - уникальный идентификатор.

Я считаю, что самым правильным подходом для создания ИИ систем будет создание единого вида базового представления данных, информации и знаний. А именно - в виде аналогичном записи данных в СУБД. С назначением каждой единице информации уникального идентификатора. Идентификатором внутри одной БД может быть простое целое число. Однако, не следует ограничивать хранение информации только в одной БД. Поэтому предлагаю использовать гибридный идентификатор вида: //localhost/path/to/db/123456
где localhost/path/to/db/ - путь к БД, 123456 - уникальный номер записи внутри этой БД.

Таким образом можно будет обратиться к каждой конкретной записи данных на локальной машине, а так же в сети, используя запись вида: //aikernel.org/path/to/db/12345 или //username:password@aikernel.org/path/to/db/12345. При этом можно предусмотреть разные протоколы доступа к записям: http://aikernel.org/path/to/db/123456, ftp://aikernel.org/path/to/db/123456 или myprotocol://aikernel.org/path/to/db/123456.

Однако, такой вид представления данных, не дает ничего принципиального нового. Требуется уточнение структуры данных каждой такой записи, так же требуется указание о том как использовать информацию, которая там хранится и т.д. Предлагаю указывать это записывая тип блока данных. Типом блока данных может служить указатель на другой блок данных в котором будет содержаться информация о структуре данных, методах его обработки и использования. Такой блок данных я назвал "сущность" (от слова существует).

[b]Вид представления данных в виде сущностей[/b]

В общем сущность в программе можно записывать примерно так:
[code]type
  TAEntity = packed record // Сущность
    EntityID: Integer; // Идентификатор сущности (блока данных) в локальной БД
    EntityType: Integer; // Тип сущности - идентификатор в локальной БД
    DataLength: Integer; // Размер блока данных
    Data: Pointer; // Указатель на блок данных
  end;[/code]

В общем-то такой вид представления информации не многим отличается от простой записи данных без указания типа. Однако, задав базовые типы данных, можно будет использовать их в разных программах с элементами ИИ. Таким образом обеспечится взаимодействие различных ИИ систем. А это, в свою очередь, на один шаг приблизит нас к решению основной задачи - к ИР.

[b]Основные типы сущностей[/b]

Какие именно должны быть основные типы данных я, до сих пор, еще не знаю.
Возможно, что нужно, дать программе возможность хранения и обработки простых типов данных, таких как Integer, Float и т.д.
Например можно создать первую БД сущностей (//aikernel.org/entities/base0.xml) с такими записями:
[code]0 - Зарезервировано
1 - Ссылка на внешнюю БД сущностей
2 - Byte (UInt8)
3 - Word (UInt16)
4 - LongWord (UInt32)
5 - UInt64
...
8 - Int8
9 - Int16
10 - Int32
...
16 - String (WideString, UTF16)
...
32 - OntologyTriplet (Субъект-Предикат-Объект)
...[/code]

В файле эти данные можно записать, например, в таком виде:
[code]<xml>
  <entity id=2 name="Byte" />
  <entity id=10 name="Int32" />
  ...
  <entity id=32 name="OntologyTriplet" comment="This is triplet for ontology">
    <data>
      <node name="Subject" type=10 />
      <node name="Predicate" type=10 />
      <node name="Object" type=10 />
    </data>
  </entity>
</xml>[/code]

При этом сами данные, внутри программы, можно записывать примерно так:
[code]const
  // Ссылка на сущность Byte во внешней БД
  AByteType: TAEntity = (
    EntityID = 2;
    EntityType = 1;
    DataLength = {Размер данных};
    Data = {Указатель на строку "//aikernel.org/entities/base0.xml/2"}
  );
  // Ссылка на сущность OntologyTriplet во внешней БД
  AOntoTripletType: TAEntity = (
    EntityID = 32;
    EntityType = 1;
    DataLength = {Размер данных};
    Data = {Указатель на строку "//aikernel.org/entities/base0.xml/32"}
  );
  // Объект с полезными данными
  Triplet1: TAEntity = (
    EntityID = 12345; // Уникальный идентификатор в локальной БД
    EntityType = 32; // Тип 32 - это триплет
    DataLength = 12{Размер данных};
    Data = {Указатель на блок данных с указанием идентификаторов Субъекта, Предиката и Объекта. Например (1234, 1235, 1236)}
  );[/code]

С одной стороны, такой вид представления информации усложняет работу. Однако, если мы сможем прийти к единому виду представления и обработки информации, то выиграют все. Вид представления в виде сущностей, по моему, вполне может для этого подойти.
