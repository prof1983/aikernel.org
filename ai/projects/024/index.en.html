<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<meta name="Keywords" content="AI, ИИ, Artificial Intelligence, Искусственный Интеллект, Artificial Reason, Искусственный Разум, Robot, Робот, Robots, Роботы">
<title>AI - Neuronium</title>
<link rel="stylesheet" type="text/css" href="../../styles.css">
</head>

<body>
<p><a href="index.en.html">en</a> <b>ru</b></p>


<h1>Neuronium</h1>

<p>Автор: Виктор Казаринов</p>

<p>Много раз я собирался взяться за новый проект, несколько лет. Но вот - решился.</p>


<h3>Предыстория</h3>

<p>С 2000 года приблизительно я разрабатывал вплоть до 2009 года проект AIGod.
Центральной частью там было ядро виртуальной 64 битной машины демонов.
Само ядро написано на Masm. Но т.к. оно совсем небольшое, то была идея сделать портирование на несколько разных ОС.
Однако демоны - это хоть и не очень большие, но полноценные программные процессоры с собственной системой команд.
Получалось, что виртуальная машина сначала интерпретировала каждую команду демона, затем выполняла ее.
Далее - переходила к следующему демону. И так далее по циклу.
Немного напрягало то, что в памяти каждый демон должен был занимать одинаковое по размеру с другими демонами немалое место.
Это приводило к тому, что в ОЗУ можно было размещать не очень много демонов.</p>

<p>Кроме того, неясным был ответ на вопрос - как же организовать эффективную совместную работу множества демонов для выполнения полезной работы.</p>

<p>Тогда в 2006 году я обратил внимание на CLIPS - движок экспертных систем на основе продукционных правил.
В нем я рассматривал некий эквивалент моим демонам в виде правил и фактов.
Эта система мне и сейчас очень нравится своей продуманностью и я ее буду развивать.</p>

<p>Но применить в реальных роботах или других сложных задачах CLIPS вряд ли удастся - правила интерпретируются довольно медленно,
отсутствует реальный параллелизм. Есть и еще ряд неустраивающих меня недостатков.</p>

<p>Поэтому я решил приступить к новому проекту Neuronium как сплаву моих познаний и опыта создания AIGod,
а также исследования изнутри системы CLIPS.
Мне кажется, что он совместит в себе все лучшие черты нейросетей, продукционных правил,
микромультиагентности и работы с онтологиями посредством сети нейроподобных элементов.</p>


<h3>Основы</h3>

<p>Neuronium состоит из трех основных частей:</p>

<ol>
  <li>Система программирования/компиляции/отладки/наполнения дефолтными знаниями.</li>
  <li>
    Run-time система выполняющая реальную работу. Эта система в свою очередь состоит из:
    <br>2.1. Набор NeuroEngines.
    <br>2.2. Набор IOEngines.
  </li>
  <li>Консоль управления. С ее помощью происходит управление всеми NeuroEngines и IOEngines.</li>
</ol>

<!---
1. Система программирования/компиляции/отладки/наполнения дефолтными знаниями.
2. Run-time система выполняющая реальную работу. Эта система в свою очередь состоит из:
2.1. MainSystem - управляющая подсистема. Она организует весь вычислительный процесс, создание и уничтожение Engines, загрузку и выгрузку текущего состояния или дефолтных нейросетей, общий сброс системы, инициализацию, взаимодействие всех Engines между собой.
2.2. Набор NeuroEngines.
2.3. Набор IOEngines.
--->

<p>Главным элементом проекта является нейроподобный компонент.
Но это вовсе не искусственный нейрон в обычном понимании этого слова.
Скорее всего это предельно упрощенный демон из моего проекта AIGod,
который может выполнять самые разные операции вплоть до создания и уничтожения других таких же компонентов как он.
Но особенность его в том, что выполнять в каждый такт времени он должен всего одно элементарное действие, функцию,
а не очередную команду большой программы на своем виртуальном машинном языке, как это было в AIGod.
Тогда практически почти весь алгоритм будет не внутри демона а снаружи него.
Особое внимание обращу на получение предельной скорости работы системы,
а также - ясности и удобства человека в процессе проектирования прикладных систем на основе Neuronium.</p>

<p>Run-time систему возьму переработанную от AIGod.
Ее впоследствии можно будет легко портировать под разные ОС или даже в 32 битные микроконтроллеры.
Систему программирования/компиляции/отладки писать буду наверное на C Builder. Мне он нравится больше чем MSVS.
Но я тут еще до конца не определился. М.б. что-то кроссплатформенное выберу. Например, QT или даже Java.</p>

<p>Каждая Engine взаимодействует с внешним миром через TCP/IP протокол,
даже если другие аналогичные Engines выполняются в одном общем адресном пространстве компьютера.
Это несколько замедляет процесс обмена, но позволяет макимально упростить построение большой сети, состоящей из таких Engines.</p>

<p>Вот общая суть вкратце. Если кому-то будет интересно поучаствовать - я совершенно не против.
<!--- Но, думаю, таких не найдется. Поэтому буду хотя бы сообщать о текущем состоянии работ. ---></p>


<h3>Что должен делать Neuronium?</h3>

<p>1. NeuroniumStudio:
<br>1.1. Платформа для разработки различных программ, особенно для параллельного и последовательно - параллельного программирования.
А также для других парадигм программирования: ООП, АОП...
<br>1.2. Платформа для разработки структур данных/знаний в различных парадигмах. Онтологческих, фреймовых и др.
<br>2. Neuronium.exe - это главный модуль всей системы. Это движок псевдопараллельной виртуальной машины.
В нем и происходит вся главная обработка информации.
<br>3. IO модули позволят работать с изображенями, например, с камерами робота, звуком, базами данных, приводами роботов, оборудованием "умного дома" и т.д.
Т.е. все специфическое будет стыковаться с Neuronium.exe через такие модули - драйверы,
в которых будет проходить первичная обработка информации и управление эффекторами.</p>


<!---
Такое уже многократно делалось. См, например, на статьи J.-C. Heudin по EVA (evolutionary virtual agent) - у него тоже были и демоны-агенты, и виртуальные машинные языки, и несколько "сред" (у Вас - engines) на одном компе (внутри каждой "среды" живёт один или несколько агентов, общаются они как в пределах среды, так и могут посылать сообщения другим средам, а эти среды разошлют сообщения по своим агентам), и т.д
--->

<!---
Если программисту необходимо свои или чужие формализованные знания выразить в программном коде или в структурах данных,
то он это может сделать почти на любом языке программирования.

Я же хотел бы добиться чего-то подобного, как в Искусственные: память, сознание, интеллект... ,
только для более широкого круга задач - создание растущих и перестраиваемых онтологий,
состоящих из нейронов на основе выделения закономерностей мира.
Однако, некоторый небольшой запас дефолтных знаний, созданный либо вручную,
либо обучением предыдущего экземпляра сети различными способами системе все же не повредит.
--->

<p><a href="http://www.ritis.ru/protar/index.php?protar=1">http://www.ritis.ru/protar/index.php?protar=1</a> - Искусственные: память, сознание, интеллект...</p>


<p>Для упрощения текущей версии Neuronium каждую Engine я запускаю как отдельное приложение.
И уже средства ОС сами раскидывают по ядрам. TCP в свою очередь синхронизирует потоки приложений - множества Neuronium Engines.
Для этого в Neuronium есть отдельный поток ядра и поток I/O.
Поэтому взаимодействие между процессами не тормозит основной вычислительный процесс.
Приостанавливают свою работу лишь те демоны, которые занимаются I/O операциями.</p>

<p>Как совершенно правильно заметил shuklin, я вовсе неоригинален в этом жанре.
Но каждая имплементация аналогичной системы может учитывать чужие разработки, что-то свое привносить,
менять какие-то элементы и этим менять общие свойства системы.</p>


<h3>Проект закрытый, открытый или частично открытый?</h3>

<p>Я решил делать проект Neuronium на основе проекта AIGod, довольно сильно его модернизировав.
Не буду с нуля делать новый проект. Сил не хватит. Негоже пропадать работающему добру.
Как и в проекте AIAssistant хотел бы сделать ассемблерную часть закрытой по ранее озвученным причинам и по причине того,
что в ассемблере разбираться вряд ли кто захочет. Поэтому собственно ядро системы в общем то уже есть.
Нужно будет писать еще код для демонов- нейронов, который на виртуальном ассемблере и прошивается в их виртуальные ROM (ПЗУ).</p>

<!--- Тут можно либо вместе с кем-то делать, либо я сам попишу код. Специфика тоже в языке есть.
Думаю, и на эту писанину желающих не найдется.
А вот придумать язык высокого прикладного уровня, который описывает сети демонов - это запросто можно колхозом делать.
Но, думаю, и тут никого желающего не найдется. Так что судя по всему - тянуть лямку придется одному.
Таким образом - язык высокого уровня - открытый. Низкого - закрытый. --->

<p>И еще - на этом параллельном языке высокого уровня нужно что-то реально работающее написать для
демонстрации возможностей системы и выявления ее отличий от других аналогичных систем.</p>

<!--- Лицензия - да фиг ее знает - эту лицензию. Для личного употребления СНГ- совместимым юзерам- бесплатно, остальным платно. Вроде бы что-то такое. --->

<h3>Какие правила участия в проекте?</h3>

<p>Не знаю. Предлагайте.</p>

<h3>Какие именно требования предъявляются к желающим участвовать?</h3>

<p>Никаких особых требований. Было бы желание. А работы на любого энтузиаста хватит.</p>

<p>Начинаю перепахивать ассемблерный код и рисовать структурную схему проекта.
Думаю, что все энжины могут соединяться между собой даже в одном адресном пространстве компьютера по TCP протоколу.
Несмотря на некоторые недостатки такой соединение модулей позволяет добиться максимальной гибкости и независимости этих модулей.
А язык их взаимодействия тоже уже есть. За основу взята рекомендация FIPA - язык ACL.
Я на робофоруме его немного перевел <a href="http://roboforum.ru/wiki/RoboBrain_Interchange_Language">http://roboforum.ru/wiki/RoboBrain_Interchange_Language</a>.
Но м.б. и другой язык обмена выбран. Кроме того, ACL язык - это все равно обертка.
Внутри сообщения будут видимо на каком- нибудь онтологическом языке знаний.</p>

<!---
А для параллельных вычислений сможет видеокарты (CUDA) использовать?
Пока CUDA имплантировать не планирую. Хотя это сейчас модно. Сначала нужно добиться правильной фунциональности средствами CPU, а затем выжимать всю скорость из компа с пом. видеокарточного проца. Я вообще-то считаю, что рано или поздно проц с пом нормальных обычных универсальных команд будет осуществлять все операции в т.ч. и графические. А CUDA - это временная технология. Продуктивнее дождаться нормальной мультипроцессорности обычного компа, т.к. многоядерность скоро станет ограничивающим фактором. Когда они на проце разместят 10 тыс ножек, м.б. остановятся? А то память то по прежнему двухканальная - вот где узкое место. В свое время транспьютеры Inmos мне нравились. Но у них свои проблемы были.
Для упрощения текущей версии Neuronium каждую Engine я запускаю как отдельное приложение. И уже средства ОС сами раскидывают по ядрам. TCP в свою очередь синхронизирует потоки приложений - множества Neuronium Engines. Для этого в Neuronium есть отдельный поток ядра и поток I/O. Поэтому взаимодействие между процессами не тормозит основной вычислительный процесс. Приостанавливают свою работу лишь те демоны, которые занимаются I/O операциями.
--->

<h3>Наверно знания будут очень разные, Вы собираетесь как-нибудь отслеживать их корректность?</h3>

<p>Я надеюсь на то, что онтологический подход в этом деле поможет.
Если новые знания сразу укладывать в нужные места, добавляя листья к единому дереву онтологии, то этим корректность будет соблюдена.</p>

<ul>
  <li><a href="http://ai.obrazec.ru/forum/viewtopic.php?t=2316">http://ai.obrazec.ru/forum/viewtopic.php?t=2316</a></li>
  <li><a href="http://www.gotai.net/forum/Default.aspx?postid=50325#50325">http://www.gotai.net/forum/Default.aspx?postid=50325#50325</a></li>
  <li><a href="http://ailab.ru/forum/deyatelnost/predlojeniya-proekti-razrabotki/proekt-neuronium.html">http://ailab.ru/forum/deyatelnost/predlojeniya-proekti-razrabotki/proekt-neuronium.html</a></li>
</ul>


<!--- If you add a new language here, please advise prof1983@yandex.ru --->

<p><font size=2>
<hr>&copy; AIKernel 2011
<br>10.05.2011 - 12.05.2011
</font>
</body>
</html>
