<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="ru">
<meta name="Keywords" content="AI, AGI, ИИ, Artificial Intelligence, Искусственный Интеллект, Artificial Reason, Искусственный Разум, Robot, Робот, Robots, Роботы">
<title>Open Semantic Technology for Intelligent Systems (OSTIS)</title>
<link rel="stylesheet" type="text/css" href="../../styles.css">
</head>

<body>


<!-- header begin -->
<table border="0" width="100%">
<tr><td>
<!-- header end -->


<p><a href="index.en.html">en</a> <b>ru</b></p>


<h1>Open Semantic Technology for Intelligent Systems (OSTIS)</h1>

<p>Это открытый проект, направленный на создание массовой семантической технологии компонентного проектирования интеллектуальных систем различного назначения.</p>

<p><a href="http://www.ostis.net/">ostis.net</a></p>

<h2>Цели проекта OSTIS</h2>

<ul>
<li>Создать массовую, комплексную и активно развивающуюся технологию проектирования интеллектуальных систем, включающую в себя теоретические и практические, программные и аппаратные аспекты</li>
<li>Создать инфраструктуру, обеспечивающую сочетание научной и учебной, инженерной и коммерческой деятельности в области искусственного интеллекта</li>
</ul>

<h2>Особенности проекта OSTIS</h2>

<ul>
<li>Является открытым комплексным проектом, состоит из большого числа частных проектов и предоставляет полный пакет документации по всем компонентам предлагаемой технологии (включая исходные тексты соответствующих программных средств)</li>
<li>Ориентирован на широкий контенгент разработчиков прикладных интеллектуальных систем (на массовое распространение предлагаемой технологии)</li>
<li>Ориентирован на существенное сокращение сроков проектирования интеллектуальных систем</li>
</ul>


<h2>Модель интеллектуального решателя задач</h2>
<p>
В предлагаемом подходе к преодолению приведенных проблем решатель задач
рассматривается в неклассическом варианте. В
данном случае решатель задач представляет собой
графодинамическую sc-машину (память в качестве
модели представления знаний использует
семантическую сеть), состоящую из двух частей:
<ul>
<li>графодинамической sc-памяти;</li>
<li>систему sc-операций.</li>
</ul>
</p>

<p>Система операций является агентно-
ориентированной и представляет собой набор
sc-операций, условием инициирования которых
является появление в памяти системы некоторой
определенной конструкции. При этом операции
взаимодействуют между собой через память системы
посредством генерации конструкций, являющихся
условиями инициирования для другой операции. При
таком подходе становится возможным обеспечить
гибкость и расширяемость решателя путем
добавления или удаления из его состава некоторого
набора операций. Более подробно процесс
проектирования операций и предъявляемые к ним
требования рассмотрены в соответствующем разделе.</p>

<p>Отличительной особенностью решателя задач как
многоагентной системы в рамках данного подхода
является принцип взаимодействия операций-агентов.
Агенты обмениваются сообщениями исключительно
через общую память путем использования
соответствующего языка взаимодействия (языка
вопросов-ответов), в отличие от большинства
классических многоагентных систем, в которых
агенты обмениваются сообщениями непосредственно
друг с другом. В рассматриваемом подходе каждый
агент, формулируя вопросную конструкцию в
памяти, априори не знает, какой из агентов будет
обрабатывать указанную конструкцию, а лишь
дожидается появления в памяти факта окончания
обработки вопроса. При этом в решении
поставленной таким образом задачи может
принимать участие целый коллектив агентов.
Аналогичным образом, реагируя на появление
некоторой конструкции в памяти, агент в общем
случае не знает, кто из его коллег поставил данный
вопрос, а лишь может проверить соответствие
сгенерированной конструкции своему условию
инициирования. В случае наличия такого
соответствия, агент начнет обработку указанного
вопроса (решение поставленной задачи), и в
результате работы сгенерирует некоторый ответ на
поставленный вопрос.</p>

<p>Проверка соответствия сгенерированного вопроса
условиям инициирования агентов происходит
следующим образом: автору вопроса после его
формулирования необходимо инициировать данный
вопрос (включить его во множество
инициированных вопросов). После инициирования
вопроса каждый из агентов, работающих в памяти,
переходит в активное состояние и начинает проверку
условия инициирования. При этом проверка
начинается с наиболее уникальных фрагментов
условия (например, типа вопроса) с целью
оптимизации данного процесса.
В случае установления факта изоморфности вопросной
конструкции и условия инициирования агент
начинает решение поставленной задачи, в противном
случае агент переходит в состояние пассивного ожидания.</p>

<p>Описанная модель взаимодействия агентов в общей
памяти позволяет обеспечить максимальную
расширяемость системы агентов и предельно
упростить процесс добавления новых агентов в уже
имеющийся коллектив.</p>


<h2>Файлы</h2>

<a href="../../files/ostis/kbe-0.2.0-src.7z">kbe-0.2.0-src.7z</a>

<h2>Ссылки</h2>

<p>
Основной сайт проекта:
<a href="http://www.ostis.net/">ostis.net</a>
</p>

<p>
<a href="http://www.project-ai.org/forum/viewtopic.php?p=1052#p1052">Подробное описание + видео</a>
</p>

<ul>
<li><a href="http://www.ostis.net/resources/wiki.html">Документация</li>
<li><a href="http://www.ostis.net/wiki/%D0%9F%D1%80%D0%B5%D0%B7_%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8_%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8_%D0%B7%D0%BD%D0%B0%D0%BD%D0%B8%D0%B9">
Алгоритм операции обработки знаний (на языке SCP)
</a></li>
<li><a href="http://www.conf.ostis.net/index.php?title=%D0%94%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4_3.07_OSTIS-2012">
Доклад 3.07 OSTIS-2012 - Семантическая технология компонентного проектирования интеллектуальных решателей задач
</a></li>
</ul>

<p>
Интересные материалы конференции OSTIS-2012:
<br/><a href="http://www.conf.ostis.net/index.php?title=%D0%94%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4_2.10_OSTIS-2012">Разработка экспертных систем в среде Multi Studio</a>
<br/><a href="http://www.conf.ostis.net/index.php?title=%D0%94%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4_2.11_OSTIS-2012">Онтологическая парадигма программирования</a>
<br/><a href="http://www.conf.ostis.net/index.php?title=%D0%94%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4_2.12_OSTIS-2012">Языки и технологии программирования, ориентированные на обработку семантически сетей</a>
<br/><a href="http://www.conf.ostis.net/index.php?title=%D0%94%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4_3.04_OSTIS-2012">Гранулярные, нечеткие и лингвистические онтологии для обеспечения взаимопонимания между когнитивными агентами</a>
<br/><a href="http://www.conf.ostis.net/index.php?title=%D0%94%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4_3.07_OSTIS-2012">Семантическая технология компонентного проектирования интеллектуальных решателей задач</a>
<br/><a href="http://www.conf.ostis.net/index.php?title=%D0%94%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4_3.09_OSTIS-2012">Использование онтологий при построении систем распознавания образов</a>
</p>


<h2>Заметки</h2>

<p>По ходу дела буду записывать заметки, чтобы самому не забыть и с другими поделиться. И так, описание монографии:</p>

<p>1. В монографии говорится о системе из БЗ и интерпретаторов (движков логического вывода).</p>

<p>2. Знания могут быть представлены в разных видах: формальные, семиотические, графодинамические.
<br/>Если по русски, то или последовательные (строки) или в виде графов (онтология на сколько я понимаю).</p>

<p>3. Сущности (знаки, денотаты) могут быть представлены в виде фреймов.
<br/>Цитата: Очевидно, что сетевые модели представления знаний, в которых знания представляются в виде семантических сетей, устроенных тем или иным способом, имеют к графодинамическим моделям переработки знаний самое непосредственное отношение, ибо семантическая сеть есть частный вид графовой конструкции.</p>

<p>4. Говорится о графах, семантических сетях, сетях "знаков" и пр. Кроме этого, говорится что сети - это частный случай фреймого вида. Т.к. сеть можно записать в виде фреймов.
<br/>Я предпочитаю называть все эти варианты сетей одним словом (понятием) - "онтология". То есть, по сути, знания они и есть знания (онтология). В каком бы виде из не записал - все равно суть остается. В общем-то об этом так или иначе в монографии говорится. Например на стр.43-44.</p>

<p>5. Говорится об одновременно переработке общих знаний. Я так понимаю обрабатывают знания агенты. Получается модель с "микроагентами", когда обработка онтологии происходит одновременно несколькими подпроцессами параллельно.
<br/>Как это реализовывается на практике - не понятно, но приводятся математические выкладки с множествами и пр, которые я не понимаю.</p>

<p>6. Базовая семантическая информационная конструкция - это базовая онтология. В ней записаны некоторые общие сущности (знаки) на основе которых создаются другие онтологии (знания).
<br/>Есть несколько универсальных базовых онтологий. Самая известная и простая, на сколько мне известно, это SUMO.</p>

<p>7. Говорится о том, что есть несколько вариантов сущностей (знаков): объекты, экземпляры, свойства.
<br/>Хотя я считаю, что типов сущностей может быть намного больше. Но не все сущности могут учавствовать в логическом выводе. Хотя, например, такие сущности как изображение или видеозапись может выступать в роли экземпляра (Individual) и учавствовать как единица семантической сети.</p>

<p>8. Далее описываются языки представления онтологий (семантические и не семантические). Рассматриваются разные признаки классификации языков. Есть даже такой признак, как "мощность языка". :)
<br>Но ясно, что рассматривать стоит только универсальные "мощные" языки в которых информация и метаинформация записывается вместе, в едином виде.</p>

<p>9. Предлагаются языки SC (Semantic Code) (раздел 4) и SCL (Semantic Code Logic) (раздел 5).</p>

<p>Семантические сети (онтологии) - это самый молодой и самый перспективный вид представления знаний.</p>

<p>В монографии используются понятия "знак", "фрейм" и пр. На мой взгляд правильнее эти единицы знаний называть "сущность".</p>


<h2>23.04.2012</h2>

<p>Монография читается очень трудно. Я думаю это из-за того, что терминология которая используется не соответсвует стандартам OWL. Это, скорее всего, связано с тем, что монографти я выпущена в 2001 году, а стандарт OWL выпустился в 2003 году (2003-06-11).</p>

<p>Однако в монографии присутсвуют очень полезные мысли. В частности увязаны между собой различные языки описания знаний. В частности графические, где различные связи обозначаются стрелочками. Очень наглядно и удобно. Такого я еще нигде не встречал.</p>

<p>
Но перед прочтением монографии нужно быть уже маленько подготовленным. Я бы рекомендовал сначала почитать стандарт OWL:
<br/><a href="http://shcherbak.net/translations/ru_owl2primer_shcherbak_net.html">shcherbak.net/translations/ru_owl2primer_shcherbak_net.html</a>
<br/>А перед этим посмотреть "Концепция семантического Web и интеллектуальные агенты":
<a href="http://aikernel.org/ai/books/semantic_web_and_agents.7z">aikernel.org/ai/books/semantic_web_and_agents.7z</a>
</p>

<p>
Вот еще ссылка по теме:
<a href="http://www.w3.org/standards/techs/owl">w3.org/standards/techs/owl</a>
</p>


<h2>24.04.2012 DenisKoronchik</h2>

<p>
OSTIS - это технология, а не редактор БЗ + ряд возможностей. KBE - это лишь малая часть всего. Кстати его исходники можно найти по ссылке:
<a href="https://github.com/deniskoronchik/kbe">github.com/deniskoronchik/kbe</a>
. А скачать последние версии под windows по ссылке:
<a href="http://sourceforge.net/projects/ostis/files/tools/">sourceforge.net/projects/ostis/files/tools</a>
</p>


<h2>25.04.2012</h2>

<p>
Материалов конференции OSTIS, действительно, очень много. Я потратил почти целый день чтобы просто пролистать материалы с конференции OSTIS-2012.
<br/>Все описания можно найти и прочитать. Основная проблема - это время. К сожалению времени на прочтение всех интересующих документов нет. Поэтому нужны какие-то краткие обзоры. В принципе документация в виде wiki очень хорошая, довольно краткая но достаточная для начального понимания сути.
</p>

<p>
Программные реализации:
<br/><b>kbe</b> - Инструментальное средство для редактирования исходных текстов баз знаний
<br/><b>kpm</b> (sc-core и sc-store) - машина обработки знаний
<br/><b>sui</b> - компоненты ядра пользовательских интерфейсов написанные на Qt
<br/><b>suit</b> - Библиотека для разработки пользовательских интерфейсов интеллектуальных систем
</p>


<h2>25.04.2012 DenisKoronchik</h2>

<p>
kbe - это, как ранее было подмечено, инструментальное средство для редактирования исходных кодов баз знаний.
Если внимательно почитать первую статью в сборнике конференции за 2012 год. То можно уловить, что знания это не только факты, а и агенты, которые эти знания обрабатывают.
Поэтому kbe, включает в себя еще и средства разработки агентов (пока к сожалению этот плагин позволяет лишь редактировать их исходные коды с подсветкой синтаксиса и автодополнением).
Свежая версия исходников находится по ссылке: <a href="https://github.com/deniskoronchik/kbe">github.com/deniskoronchik/kbe</a>.
Основным же там конечно является SCg-код - один из возможных способов визуального представления SC-кода (будет интересно, расскажу поподробнее, ибо стандарт по нему мы уже зафиксировали).
</p>

<p>
kpm - там собрано все что касается обработки знаний.
В частности sc-core - это один из возможных способов реализации SC-памяти на современных платформах, он включает в себя и интерпретатор языка SCP (Semantic Code Programming).
Этот язык используется для записи агентов. И представляется с помощью SC-кода (знания, которые к слову можно генерировать, анализировать и изменять во время работы системы).
sc_store - это некий прототип на котором мы испытывали возможные способы ускорения такой реализации памяти и добились неплохих результатов, к примеру генерировали до 8 млн. узлов в секунду, при возможности масштабирования и дальнейшей параллельной обработки в том числе и на GPU.
Эксперименты удались и теперь на основе них мы будем реализовывать замену sc-core.
Проект находится по ссылке: <a href="https://github.com/deniskoronchik/sc-machine">github.com/deniskoronchik/sc-machine</a>.
А тут пополняемое описание: <a href="https://github.com/deniskoronchik/sc-machine/wiki">github.com/deniskoronchik/sc-machine/wiki</a>.
Если это будет интересно, могу выслать небольшую презентацию, где описана сама идея с цифрами и описаниями структур данных.
</p>

<p>
suit - прототип ядра пользовательских интерфейсов.
Дело в том, что пользовательские интерфейсы мы рассматриваем как интеллектуальную систему, которая просто решают задачу перевода сообщений пользователя в SC-код и обратно из SC-кода на внешний язык понятный пользователю.
Он также состоит из базы знаний и машины обработки знаний (агентов).
Отличие заключается в том, что его машина обработки знаний кроме агентов работающих только с SC-памятью имеет "эффекторные" и "рецепторные" агенты, которые направлены на вывод и ввод информации.
Строится он на основании компонентов.
</p>

<p>
Видео по установке:
<a href="http://andrey.bezrukov.me/?p=311">andrey.bezrukov.me/?p=311</a>
<br/>Видео примеров работы:
<br/><a href="http://www.youtube.com/watch?v=Ncu-qrA2TEI">youtube.com/watch?v=Ncu-qrA2TEI</a>
<br/><a href="http://www.youtube.com/watch?v=FnRhOf35FkI">youtube.com/watch?v=FnRhOf35FkI</a>
<br/><a href="http://www.youtube.com/watch?v=8k2-yxmDOB0">youtube.com/watch?v=8k2-yxmDOB0</a>
<br/><a href="http://www.youtube.com/watch?v=udQlaeEUJM8">youtube.com/watch?v=udQlaeEUJM8</a>
<br/><a href="http://www.youtube.com/watch?v=Gvs4mCwUPxE">youtube.com/watch?v=Gvs4mCwUPxE</a>
<br/><a href="http://www.youtube.com/watch?v=qx7khGSJAPA">youtube.com/watch?v=qx7khGSJAPA</a>
<br/><a href="http://www.youtube.com/watch?v=kRCE6_tmdso">youtube.com/watch?v=kRCE6_tmdso</a>
</p>

<p>suit написан на python + OGRE + OIS + MyGUI</p>

<p>sui - это альтернативный вариант suit, только реализованный на с++ + Qt. Для повышения быстродействия и ухода от прототипа в сторону реального использования.</p>

<h3>Какие есть еще проекты (подпроекты)?</h3>

<p>
<a href="https://sourceforge.net/projects/ostisgeometry/">sourceforge.net/projects/ostisgeometry</a>
<br/><a href="https://sourceforge.net/projects/ostisgraphstheo/">sourceforge.net/projects/ostisgraphstheo</a>
<br/><a href="https://sourceforge.net/projects/ostisbelarus/">sourceforge.net/projects/ostisbelarus</a>
<br/><a href="https://sourceforge.net/projects/ostisenglishlan/">sourceforge.net/projects/ostisenglishlan</a>
<br/><a href="https://sourceforge.net/projects/ostislogic/">sourceforge.net/projects/ostislogic</a>
<br/><a href="https://sourceforge.net/projects/ostisnumsys/">sourceforge.net/projects/ostisnumsys</a>
<br/><a href="https://sourceforge.net/projects/ostisphysics/">sourceforge.net/projects/ostisphysics</a>
<br/><a href="https://sourceforge.net/projects/ostisrussianlan/">sourceforge.net/projects/ostisrussianlan</a>
<br/><a href="https://sourceforge.net/projects/ostissets/">sourceforge.net/projects/ostissets</a>
</p>

<p>
В большинстве из них вы увидите исходники базы знаний представленные с помощью SCn-кода. К примеру:
<a href="http://ostisgeometry.sourceforge.net/index.php/%D0%93%D0%B5%D0%BE%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%8F:%D0%9A%D0%BE%D0%BD%D1%83%D1%81">http://ostisgeometry.sourceforge.net/index.php/Геометрия:Конус</a>
</p>

<p>Эти знания понимаются машиной. Мы использовали mediawiki как платформу для распределенной и удаленной разработки баз знаний. Далее они погружаются в sc-память средствами транслятора и могут быть использованы к примеру в рамках графического интерфейса построенного с помощью suit, sui и т. д.</p>

<h3>Расскажите пожалуйста подробнее про kpm или, лучше, дайте ссылку на описание. Какой алгоритм применяется для машины обработки знаний? (RETE?)</h3>

<p>
Сложно рассказать все сразу. Но алгоритма как такого нет. Есть просто сборище агентов, которые решают разные задачи.
Каждый агент самоинициируемый. Это можно сравнить с форумом, в аналогии агенты будут выступать в качестве форумчан.
<br/>
Предположим есть некоторый форум на который пришел человек и задал там свой вопрос.
Ему ведь далеко без разницы кто будет отвечать на этот вопрос и он не обязан знать кто это способен делать.
Его лишь интересует наличие правильного ответа. Он задает вопрос и далее на него отвечает тот форумчанин, который способен на него ответить.
<br/>
Так и у нас. В базу знаний некоторым образом попал вопрос (его сформулировал пользователь, его задал агент или еще как-то), сразу запускается агент, который способен на него ответить (запуск агентов происходит по некоторому событию в памяти: генерация узла, генерация дуги, удаление элемента, изменение элемента и т. д.).
Если же агент запустился и нашел ответ, то он достраивает его в памяти и связывает с вопросом.
При появлении ответа запускается ряд других агентов, которые решают кто был автором ответа, и если автором был пользователь, то они просят ПИ вывести ответ на некотором внешнем языке. И так далее.
Если же агент запустился и ему не хватает знания для ответа на вопрос, то он может задать другой вопрос "на форуме" и ждать ответа, а потом продолжить работу.
<br/>
Идея в том, что агенты ничего не знают друг о друге, они как на форуме общаются.
Поэтому чтобы создать машину обработки знаний, нам надо просто скинуть агентов в кучу, а дальше они сами разберуться.
Конечно для этого мы стандартизируем язык вопросов.
</p>

<h3>Что если какой-то агент будет отвечать не правильно? Реализован ли механизм отслеживания правильных и не правильных ответов? Может быть имеет смысл ввести понятие "кармы" для каждого агента?</h3>

<p>В настоящий момент в этом нет необходимости. Систему делает разработчик, именно он выбирает агентов из библиотеки компонентов или разрабатывает. Поэтому он выбирает тех, кто его больше устраивает. Плохой агент - это как плохая функция в программе, которую необходимо отладить.</p>

<p>Но не исключено, что такое понадобиться в дальнейшем, когда мы начнем говорить о анализе агентов. Так как они тоже знания, то мы можем говорить о целом ряде агентов, которые диагностируют других агентов, а возможно и себя.</p>

<!--

<h2>06.05.2012</h2>

Сегодня пытался собрать программы из исходников OSTIS. Начал с [color=#0000FF]sui[/color] (git://github.com/deniskoronchik/sui.git).

Попробовал проект в Qt и скомпилировать [color=#0000FF]sui.pro[/color]. С первой попытки не получилось. Поэтому я решил перенести исходники отдельных программ и библиотек и скомпилировать их по отдельности. А заодно попробовать интегрировать в проект [color=#0000FF]AReason[/color].

Начал с sui/app
Перенес эту директорию в /Projects/AReason/Source/OstisSui/app

За тем sui/core -> /Projects/AReason/Source/OstisSui/core
За тем sui/plugins -> /Projects/AReason/Source/OstisSui/plugins

При компиляции потребовались заголовочные файлы [color=#0000FF]libpm[/color], [color=#0000FF]libsc[/color], [color=#0000FF]libsys[/color] (для компиляции plugins/sc-core). Для компиляци app и core вроде требуется только [color=#0000FF]libsc[/color].
Эти файлы взял из SVN репозитория (trunk).

Разместил libsc в /Projects/AReason/Source/OstisSui/libsc

Скомпилировал core и app. В итоге получил следующие файлы:
/Projects/AReason/Bin/libsuiCore.so
/Projects/AReason/Bin/libsuiCore.so.0
/Projects/AReason/Bin/libsuiCore.so.0.1
/Projects/AReason/Bin/libsuiCore.so.0.1.0
/Projects/AReason/Bin/sui

Скопировал все so файлы в /usr/lib, чтобы [color=#0000FF]sui[/color] их видела.

Далее попробовал запустить sui - выдала ошибку при поиске и загрузке плагинов. Закоменнтировал поиск плагинов (см. скриншот). Перекомпилировал все, заменил so файлы в /usr/lib и попробовал запустить снова. В итоге получил другую ошибку скриншот с которой прикладываю.

[url=http://itmages.ru/image/view/509115/e98378c5][img]http://storage9.static.itmages.ru/i/12/0506/s_1336303277_9793408_e98378c5e6.png[/img][/url]

В общем у меня такой вопрос: может быть уже есть скомпилированная версия под [color=#0000FF]Ubuntu-12.04[/color]?


<h2>06.05.2012 DenisKoronchik</h2>

Для начала надо собрать http://ostis.svn.sourceforge.net/viewvc/ostis/trunk/kpm/sc-core/ там cmake проблем быть не должно.

[code]
cmake ./
make 
make install[/code] 

Дальше плагин sc-core должен собраться. Без него ничего не запуститься, это одна из реализация sc-памяти. Без памяти ничего работать не будет.

Далее в папке sui/tools надо запустить два скрипта:
[code]
checkout_tools.sh
build_kb.sh
[/code]

Они выкачают инструменты для сборки базы знаний и соберут её.

В итоге при запуске должны увидеть нечто следующее:
[img]http://s16.postimage.org/6ccnyzkac/Screenshot_from_2012_05_06_14_45_10.jpg[/img]

Но тут еще не все готово функционально, сейчас над этим работаю.
Можно пока создавать узлы (двойной клик), создавать дуги, шины, контура. Для этого переключение режимов 1,2,3,4.
Можно проводить дуги в элементы управления, они видны на экране. Пока работаю над размещением и тогда можно будет идти в ширь.


<h2>07.05.2012 DenisKoronchik</h2>

Агенты сидят постоянно с момента старта системы, ибо они могут понадобиться в любой момент. И никто не знает когда и какой из них может понадобиться.

Их нужно программировать ручками, это само собой, но возможность их генерации есть, ибо есть язык SCP, на котором они в большинстве своем и описываются, он базируется на SC-коде, поэтому мы можем работать с ними как с обычными знаниями.

Что касается слова просто, то действительно просто, если речь идет не о естественном языке.


<h2>07.05.2012</h2>

[quote="DenisKoronchik"]язык SCP[/quote]
Я ранее встречал где-то примеры и небольшое описание, но сейчас нашел только вот это:
[quote]SCP как представитель семейства языков SC
Язык SCP относится к классу языков, ориентированных на обработку не числовых видов структур в специализированной памяти (структурно перестраиваемой ассоциативной памяти). SCP является процедурным языком программирования. Язык учитывает особенности представления информации в виде графовых конструкций и позволяет их эффективно перерабатывать. Обладая мощным набором операторов, SCP позволяет производить поиск, генерацию, удаление, обработку как отдельных SC-элементов (узлов и дуг), так и целых SC-конструкций. Важнейшей особенностью языка является то, что не только данные (информация), но и сами программы представляются в виде SC-конструкций. Это позволяет перестраиваться программам в ходе их выполнения. Данная особенность редко встречается в современных языках программирования. Язык SCP ориентирован на переработку непосредственно семантических сетей, а не структур (например, списковых), с помощью которых они кодируются. Таким образом, интерпретатор языка SCP может быть реализован на современной аппаратной части, но при разработке аппаратного обеспечения ассоциативной памяти переносимость SCP гарантирована самой архитектурой языка.[/quote]
[url=http://wiki-linki.ru/Page/1546151]Источник[/url]

Где есть более подробное описание SCP?

<h2>07.05.2012 DenisKoronchik</h2>

[url]http://www.ostis.net/wiki/%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82_15[/url] - более подробное описание SCp, если его будет не достаточно выложу chm файл.
Примеры программ можно посмотреть здесь: 
[url]http://www.ostis.net/wiki/SCg-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B_scp-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC[/url] - так они записываются в памяти
[url]http://ostis.svn.sourceforge.net/viewvc/ostis/trunk/ui/system/repo/fs_repo_src/operation/[/url] и [url]http://ostis.svn.sourceforge.net/viewvc/ostis/trunk/ui/system/repo/fs_repo_src/lib/[/url] - так они выглядят на текущий момент в виде исходников (m4scp).

Чтобы много не писать дам ссылки и уточню их.
ОтветЫ на ваши вопросы находится по [url=http://conf.ostis.net/images/8/85/%D0%93%D0%BE%D0%BB%D0%B5%D0%BD%D0%BA%D0%BE%D0%B2_%D0%92.%D0%92..2012%D1%81%D1%82-%D0%93%D1%80%D0%B0%D1%84%D0%BE%D0%9C%D0%9F%D0%9E%D0%97%D0%9F%D0%9F%D0%A0%D0%B8%D0%9F.pdf]ссылке[/url]

Ответы в принципах 3, 4, 7 - 10

Там не очень, много, но если что я могу расписать все это более подробно. А вообще для понимания все картины статью лучше прочитать полностью.


<h2>08.05.2012</h2>

Сейчас пытаюсь разобраться с SCP. И у меня возник такой вопрос:
DenisKoronchik, является ли данная конструкция правильной?
[url=http://itmages.ru/image/view/510694/dd1c1aaa][img]http://storage4.static.itmages.ru/i/12/0508/h_1336434417_7494705_dd1c1aaa14.png[/img][/url]
[url=http://www.ostis.net/wiki/SCP-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D1%82%D0%B8%D0%BF%D0%B0_genEl]Источник[/url]

Что-то не вяжется описание SCP программы с моими представлениями. На мой взгляд семантикой можно описать только метаинформацию программы (то есть описать переменные, константы, процедуры, функции и пр.). Но значения переменных определить семантикой вроде бы нельзя. Но в описании SCP приводятся картинки, где значение является частью семантической сети.

Я еще понимаю, если мы создадим некоторый элемент (например "[color=#8000FF]Яблоко[/color]"), к этому элементу добавим некоторых свойств (например "[color=#8000FF]Вес[/color]", "[color=#8000FF]Цвет[/color]", "[color=#8000FF]Вкус[/color]" и т.д.). Для каждого свойства определит набор возможных значений (например для "[color=#8000FF]Цвет[/color]" зададим "[color=#8000FF]Красный[/color]", "[color=#8000FF]Желтый[/color]", "[color=#8000FF]Зеленый[/color]", "[color=#8000FF]Желто-Зеленый[/color]" и пр). При этом каждый элемент будет отдельной семантической единицей сети.


<h2>08.05.2012</h2>

[quote="Виктор Казаринов"]Как я понял, к стандартному набору команд (сложение и т.д.) вы добавили специфические для сетей операторы.[/quote]
На сколько я понял основная особенность SCP перед другими видами записи программ состоит в том, что каждый элемент SCP программы - это узел (элемент) семантической сети. А это значит, что для анализа SCP программы можно применить алгоритм логического вывода. И даже сделать автоматизированное программирование, когда код будет генерироваться сам по внешним условиям и командам.

[quote="Виктор Казаринов"]А то что программа сама может генерить SCP код - чем это радикально отличается от LISP?[/quote]
Вроде на LISP можно записать все то же самое. Но для интерпретации семантического LISP кода нужно еще будет писать сам интерпретатор. Хотя, наверное, можно воспользоваться готовыми интерпретаторами (и возможно компиляторами). И при этом останется возможность интерпретация LISP кода как семантической конструкции для логического вывода. Хотя синтаксис LISP программы не очень подходит для записи семантики. Если только дополнительное описание элементов программы (переменные, константы, операторы, команды) выносить в отдельный файл и делать описание с помощью NameSpace. Я не разбираюсь в LISP, но имею в виду что-то типа этого:
[code](Program_Type:Программа1(Operator_Type:Оператор1 Operator_Type:Оператор2) (Command_Type:Команда1() Command_Type:Команда2() ...))...[/code]где:
Program_Type, Operator_Type, Command_Type: - это определения (семантических) элементов программы.

При этом все то же самое можно записать и в виде XML кода (OWL) и в текстовом представлении (SCs).

[quote="Виктор Казаринов"] Есть еще вопросы- параллельность работы агентов обеспечивается тем, что каждый из агентов работает в своем программном потоке или как-то по другому организована псевдопараллельнось?
Сеть знаний для каждого агента своя или есть общие? Тогда как разруливается проблема общего доступа?[/quote]

[quote]...коллектива агентов, работающих над общей для них  графодинамической  памятью и обменивающихся информацией только через эту память  (в  т.  ч.  и  для  координации  своих действий).[/quote]
[quote]- хранимой графовой структуры, которые связаны с  блокируемым  элементом  выходящей  из  него (или  входящей  в  него)  парой  инцидентности принадлежащей  заданному  отношению 
инцидентности;
- запрет на генерацию заданного вида элементов в хранимой графовой структуре, которые связаны с блокируемым элементом выходящей из него (или входящей  в  него)  парой  инцидентности , принадлежащей  заданному  отношению инцидентности.[/quote]
[quote]- не  " жадничать" – не блокировать больше, чем 
надо;
- снимать свои блокировки как можно быстрее , как только  в  них  отпадает  необходимость  (т.  е. 
желательно это  делать  до  завершения  своей работы);[/quote]
На сколько я понимаю при параллельной обработке общей БЗ агентом производится блокировка на изменение рассматриваемого в данный момент элемента и связанных с ним элементов. Остальные элементы сети, при этом не блокируются. Таким образом и обеспечивается параллельна обработка. Но реальная параллельная обработка, вероятно, возможна только в разных (мало пересекающихся) предметных областях. Хотя, наверное, все зависит от алгоритма реализации логического вывода.

Резюме: На сколько я понял программной реализации мультианетной обработки SC кода пока нет. Только теоретические работы. Но теория проработана достаточно хорошо. Рассмотрены разные факторы системы. В частности параллельная обработка знаний, интерпретация, связки с другими видами представления знаний, связки с другими программами и т.д.

Теперь дело за малым - реализовать все это в виде программы. :)


<h2>08.05.2012 DenisKoronchik</h2>

[quote="prof1983"]Сейчас пытаюсь разобраться с SCP. И у меня возник такой вопрос:
DenisKoronchik, является ли данная конструкция правильной?
[url=http://itmages.ru/image/view/510694/dd1c1aaa][img]http://storage4.static.itmages.ru/i/12/0508/h_1336434417_7494705_dd1c1aaa14.png[/img][/url]
[url=http://www.ostis.net/wiki/SCP-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D1%82%D0%B8%D0%BF%D0%B0_genEl]Источник[/url]

Что-то не вяжется описание SCP программы с моими представлениями. На мой взгляд семантикой можно описать только метаинформацию программы (то есть описать переменные, константы, процедуры, функции и пр.). Но значения переменных определить семантикой вроде бы нельзя. Но в описании SCP приводятся картинки, где значение является частью семантической сети.

Я еще понимаю, если мы создадим некоторый элемент (например "[color=#8000FF]Яблоко[/color]"), к этому элементу добавим некоторых свойств (например "[color=#8000FF]Вес[/color]", "[color=#8000FF]Цвет[/color]", "[color=#8000FF]Вкус[/color]" и т.д.). Для каждого свойства определит набор возможных значений (например для "[color=#8000FF]Цвет[/color]" зададим "[color=#8000FF]Красный[/color]", "[color=#8000FF]Желтый[/color]", "[color=#8000FF]Зеленый[/color]", "[color=#8000FF]Желто-Зеленый[/color]" и пр). При этом каждый элемент будет отдельной семантической единицей сети.[/quote]

Попробую все-таки ответить на вопрос. Хотя мне он не очень понятен. Вот привожу пример (специально разукрашен).
[img]http://s17.postimage.org/4y4g2qfx9/example.png[/img]

Я здесь попытался нарисовать небольшой кусочек из scp программы, с примером о яблоке. Сразу скажу, что зеленым цветом я выделил все те элементы семантической сети, которые относятся к программе. Черным выделены знания, которые не представляют собой программу  - это просто некоторые знания записанные в базе знаний.

Что написано на рисунке:
- имеется множество всех возможных программ, ему соответствует узел с идентификатором programSCP.
- в это множество входит программа, которая не имеет идентификатора (изображается на картинке с '-' в кружочке, сейчас тип немного другой, но это не суть. Я взял за основу старую версию описания)
- из этого узла выходит дуга с атрибутом [i][b]var_[/b][/i] (входящая дуга из узла var_), на конце этой дуги располагается узел, который обозначает множество всех переменных для описываемой программы
- в это множество (таким же образом) с помощью дуг принадлежности включается две переменные: [i][b]v1[/b][/i], [i][b]v2[/b][/i]
- дальше мы вводим отношение, [i][b]значение*[/b][/i] (синоним: [i][b]быть значением переменной*[/b][/i]) - узел с идентификатором [i][b]значение*[/b][/i]. Этот узел обозначает множество всех бинарных отношений, которые связывают переменную программы с её значением. Теперь бинарной парой связываем [i][b]v1[/b][/i] и [i][b]яблоко1[/b][/i]. Эту бинарную пару с помощью дуги принадлежности включаем во множество [i][b]значение*[/b][/i], тем самым говорим, что эта бинарная связь обозначает бинарное отношение [i][b]быть значением переменной*[/b][/i]
Получаем, что наша переменная получила значение. Чтобы изменить значение переменной, нам просто надо соединить её с другим элементом сем. сети с помощью отношения [i][b]значение*[/b][/i]. Соответственно значением переменной может быть любой элемент сем. сети, даже сама эта переменная (такая рефлексия).

Что касается яблока, то как видно это просто некоторые знания в базе знаний, которые записаны в таком же виде, но сам узел яблоко может быть значением переменной scp программы. При этом он может быть связан большим количеством связок [b][i]значение*[/i][/b] с переменными различных программ. Это даже дает возможность при отладке узнать в каких программах и значением каких переменных является тот или иной объект.

Написал тяжело, но я надеюсь понятно. Если нет, то пишите я поясню.

[quote="prof1983"]
На сколько я понимаю при параллельной обработке общей БЗ агентом производится блокировка на изменение рассматриваемого в данный момент элемента и связанных с ним элементов. Остальные элементы сети, при этом не блокируются. Таким образом и обеспечивается параллельна обработка. Но реальная параллельная обработка, вероятно, возможна только в разных (мало пересекающихся) предметных областях. Хотя, наверное, все зависит от алгоритма реализации логического вывода.

Резюме: На сколько я понял программной реализации мультианетной обработки SC кода пока нет. Только теоретические работы. Но теория проработана достаточно хорошо. Рассмотрены разные факторы системы. В частности параллельная обработка знаний, интерпретация, связки с другими видами представления знаний, связки с другими программами и т.д.

Теперь дело за малым - реализовать все это в виде программы. :)[/quote]

Понимаете правильно. Реальная параллельная обработка возможна, это лишь вопрос реализации памяти. В основном блокировки нужны программам, на удаление тех или иных элементов, но никак не на генерацию. Поэтому сразу можно сказать, что в большинстве случаев генерации ничего априори не мешает (хотя могут быть экзотические случаи, но они не так уж и часты).

Там очень многое зависит от реализации sc-памяти. Представим себе, что некоторая программа хочет пытается найти все выходящие дуги для некоторого узла (сейчас мы реализуем это итератором, ибо сбор всех дуг и копирование результата не всегда оправдано, так как зачастую нам надо 3-4 элемента всего, а копировать тысячи накладно). 
Поэтому получается, что пока итератор не будет удален, мы не можем удалять те элементы, которые попадают в результат поиска. Для этого планируется использовать временные метки, которые помечают время создания или удаления элемента, что можно учитывать итератором. К примеру, если элемент удален после создания итератора, то он попадает в результат, если до, то не попадает и так далее.

Лучше глянуть вот эту [url=http://www.ostis.net/download/presentations/presentation-sc.zip]презентацию[/url]. Здесь изложены некоторые мысли по поводу того как программно реализовать sc-память. Это результаты [url=https://github.com/deniskoronchik/sc-machine]экспериментов[/url]

Сейчас у нас есть некоторая модель памяти, в которой работают агенты, но производительность оставляет желать лучшего. Реализован решатель, который решает задачи, при этом он является сборищем агентов. Ну как пилотный вариант мы используем геометрию и этот решатель решает следующие задачи (перечислю часть из тех, которые реально работают): 
- поиск площади треугольника по трем сторонам;
- найти площадь треугольника, когда известны две стороны, а третья является либо радиусом, либо диаметром некоторой окружности, для которой известна её длина;
- доказательство теорем (сейчас точно не помню, но могу уточнить если интересно)
- по сути сейчас работают задачи, с такими объектами, как точка, отрезок, окружность, треугольник, четырехугольник и их свойствами. Тестировали задачу проверки конгруэнтности двух треугольников и т. д.
- задачи классификации треугольников.

Кроме геометрии решатель тестировали и на физике: задача проверить будет ли плавать лодка, если на нее погрузили определенный груз.
Тестировали тот же решатель для поиска маршрута по рекам.
Это все делает один и тот же набор агентов. Разными являются лишь теоремы (высказывания), которые записаны в базе знаний. Все решение идет на их основе. 
Вот так к примеру записывается высказывание об равнобедренном треугольнике:
[img]http://s18.postimage.org/k5luwqz3b/opr1.png[/img]

Так что что-то рабочее уже есть, но вопрос производительности пока актуален. И производительность не агентов, а именно sc-памяти. Новая реализация может дать ускорение почти в 40 раз. К слову, на производительность влияет еще и использование пользовательского интерфейса. Он был реализован для прототипа на python, а из-за GIL, все работает в одном потоке (физически) и медленнее. Без него ряд задач решается за секунд 10, с ним за минуту. 
Многое также зависит от размера БЗ и количества высказываний в ней, но как это ускорить понятно уже сейчас и мы над этим работаем.


<h2>10.05.2012</h2>

[quote="vchc"]Честно говоря этот труд оставил у меня негативное впечатление. Классический пример потока сознания.[/quote]
Я все еще продолжаю читать понемногу. Я не согласен на счет "потока сознания". Проект OSTIS и SC - это, по видимому, труд не одного человека и не один год они этим занимаются. Другое дело, что то что описано в монографии в более удобной форме описано в стандарте OWL.

Но я подозреваю, что работа над монографией велась еще до появления OWL, SUMO, WordNet и пр. Просто технологии появляются намного быстрее чем выпускают монографии (у нас, в бывшем СССР). 

Однако хороших маслей (в старой) монографии много и когда читаешь, то невольно задумываешься над той или иной проблемой. Но все же читать довольно трудно. Скорее всего я не смогу дочитать до конца.

[quote="DenisKoronchik"]Агенты сидят постоянно с момента старта системы, ибо они могут понадобиться в любой момент. И никто не знает когда и какой из них может понадобиться.[/quote]
Подскажите пожалуйста где посмотреть реализацию агентов в исходниках? Файлов *agent* не обнаружил. Агенты реализованы в [color=#4000FF]sc-core[/color] или в другом подпроекте?

[quote="DenisKoronchik"]Попробую все-таки ответить на вопрос. Хотя мне он не очень понятен. Вот привожу пример (специально разукрашен).
Изображение...[/quote]
Все пытался понять что же имелось в виду. И до меня наконец дошло, что картинка не отображается.
Перезапостил ее:
[url=http://itmages.ru/image/view/513179/ace995d8][img]http://storage5.static.itmages.ru/i/12/0510/s_1336665270_8694040_ace995d82f.png[/img][/url]

Для размещения изображений рекомендую пользоваться вот этим: [url=http://forum.runtu.org/index.php/topic,1597.0.html]Руководство по добавлению изображений на форум[/url].

[quote="DenisKoronchik"]Вот так к примеру записывается высказывание об равнобедренном треугольнике:
Изображение[/quote]
Вот еще одно изображение, которого не видно:
[url=http://itmages.ru/image/view/513198/f1fa9d9c][img]http://storage6.static.itmages.ru/i/12/0510/s_1336666251_4033709_f1fa9d9c2f.png[/img][/url]


<h2>12.05.2012 DenisKoronchik</h2>

[quote]Подскажите пожалуйста где посмотреть реализацию агентов в исходниках? Файлов *agent* не обнаружил. Агенты реализованы в sc-core или в другом подпроекте?[/quote]

Речь о реализации самих агентов? Если то, то вот на scp к примеру: [url]http://ostis.svn.sourceforge.net/viewvc/ostis/trunk/ui/system/repo/fs_repo_src/operation/search_identifiers.m4scp?revision=1188&view=markup[/url] - это агент поиска всех идентификаторов указанного объекта, могу если понадобиться пояснить что там и к чему.

Если речь о том, как они реализуются на уровне памяти, то смотреть надо в sc-core/libsc, на класс [url=http://ostis.svn.sourceforge.net/viewvc/ostis/trunk/kpm/sc-core/libsc/libsc/sc_event.h?revision=1188&view=markup]sc-event[/url] (класс, который обеспечивает реакцию на события в sc-памяти) и также [url=http://ostis.svn.sourceforge.net/viewvc/ostis/trunk/kpm/sc-core/libpm/libpm/sc_operation.h?revision=1188&view=markup]ScOperation[/url] (базовый класс для операций реализуемых с помощью c++).

[quote="prof1983"]
Ярослав, в наше время куда важнее не сами мысли, а способность этих мыслей овладевать умами других людей :)

В общем с критикой я завязываю и желаю проекту Дениса только развития как и всем нашим начинаниям.[/quote]

Именно над подачей мы и работаем, но тут надо и не идти на поводу за простотой. Ибо наш результат - это формальный текст. Мы пишем документацию, так чтобы она еще и машиной понималась, а не только человеком. Поэтому чем-то приходится жертвовать. Но мы работаем над этим очень усердно и надеюсь что скоро все будут приятно удивлены.

Что касается проекта, то это вовсе не мой проект, я просто один из разработчиков.


<h2>15.05.2012 DenisKoronchik</h2>

<b>
prof1983:
1. В проектах OSTIS и SC идет работа в том числе по описанию некоторых знаний - по сути составление онтологий. Однако в монографии и в других описаниях не используются общепринятые термины и определения. Возникает вопрос: почему?
2. На сколько я понял в проекте OSTIS нет единой базовой онтологии. Есть планы по ее созданию? Какие варианты рассматривали? Рассматривали-ли вариант использования онтологии SUMO?
</b>

Не используются общепринятые термины по многим причинам. Да мы стараемся использовать по максимуму из того, что уже есть.
Но тут дело очень тонкое, важно, чтобы термин максимально возможным образом отражал семантику того объекта, который обозначается этим термином, поэтому многие из существующих терминов нам не очень подходят. А ради них губить вкладываемый смысл не очень то и хочется. Зачем создавать кашу.

В проекте OSTIS, есть множество языков описания знаний, к ним относятся: sc-язык описания логических выражений (SCL), sc-язык описания программ обработки БЗ (SCP), sc-язык множеств, sc-язык числовых систем, и т. д.
Если хотите, то можно это назвать онтологиями в некотором смысле.


<h2>15.05.2012</h2>

[quote="DenisKoronchik"]Если хотите, то можно это назвать онтологиями в некотором смысле.[/quote]
Помоему все языки SC* - это разнаф форма записи онтологических данных (или просто онтологий). Каждая [url=http://ru.wikipedia.org/wiki/%CD%EE%F2%E0%F6%E8%FF]нотация[/url] SC представления служит для своей области применения: или для записи логических выражений, или для записи данных в виде текса (SCs) или в графическом представлении (SCg) и т.д. Вот только терминологию, по моему, лучше использовать общепринятую. Иначе сложно разбираться.

Например в OSTIS принято называть два объекта и связь как "пара", хотя это на самом деле один [url=http://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D0%BD%D1%82%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B9#.D0.98.D0.BD.D1.84.D0.BE.D1.80.D0.BC.D0.B0.D1.82.D0.B8.D0.BA.D0.B0]триплет[/url] состоящий из трех элементов.
Про тириплет:
[quote]Программных средств для отображения онтологий в основном разрабатываются для управлениями схемами баз данных,[2], XML schema[3], таксономиями[4], формальными языками, ER-моделями данных[5], словарями и другими моделями данных. Исходные структуры обычно перед отображением преобразовываются в граф. С возникновением семантической паутины такие графы могут быть представлены с помощью Resource Description Framework триплетов в форме <субъект, предикат, объект>, см. синтаксис нотации 3. В англоязычной литературе «отображение онтологий» (ontology alignment), в случае, когда работают с онтологиями в формате RDF триплетов, называют «ontology mapping».[/quote]

Кстати, про нотации (как вид записи/представления онтологий)... Вот: [url=http://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F_3]Нотация 3[/url]

Лично я рассматриваю OSTIS и SC как один из вариантов записи онтологий. При чем довольно удобный и хорошо документированный вариант. Я пробовал составлять онтологии в XML(OWL) виде, в N3 и др. Но графический вид в KBE (0.3) создавать онтологии намного удобнее. Хотя я бы кое что изменил, но надо для начала поразбираться. Возможно я просто чего-то недопонимаю.

Обсуждение уже разрослось на пять страниц. Лично мне не очень нравится долго листать страницы в поисках той или иной записи. Максимальный удобный для пользования размер ветки обсуждения - не более 10 страниц. Поэтому, наверное, технические вопросы по проекту OSTIS лучше задавать на его новом форуме.

Новый форум располагается тут: [url=http://forum.ostis.net/]forum.ostis.net[/url]
Старый форум располагается тут: [url=http://www.ostis.net/forum/]http://www.ostis.net/forum/[/url] (не работает регистрация)

Кстати, DenisKoronchik, содержимое старого форума будет переносится в новый или нет?


<h2>15.05.2012 DenisKoronchik</h2>

Маловероятно ибо там мало по настоящему ценной информации. В любом случае пока вопрос открытый. Все будет зависеть от того как мы накатим документацию новую (та что есть полностью переделывается и дополняется). В любом случае старая документация, старый форум будут доступны некоторое время.

[quote="prof1983"] Например в OSTIS принято называть два объекта и связь как "пара", хотя это на самом деле один [/quote]

Это и есть пара объектов. Не стоит путать информацию и то как она представляется. На уровне представления это тройка. Но в данном контексте её уместнее называть парой.

Мы тут готовим новый scs-код он вас приятно удивит. Он удивит всех кто работал с rdf.

Что касается RSS, подписаться на блог, там основные новости: http://blog.ostis.net/?feed=rss2

-->


<h2>01.08.2012 - Краткий отчет</h2>

<p>В последнее время для людей, которые наблюдают за проектом со стороны могло показаться, что в нем ничего не происходит. Это не так. Последние месяцы мы потратили на то чтобы зафиксировать стандарты и правила их описания и последующего изменения. Большое количество работы было проделано над языками текстового представления SC-кода: scs, scn.</p>

<p>Описание стандарта будет выложено в ближайшее время. На основе данного языка были разработаны инструменты, которые позволяют делать интернет ресурсы, которые в основе своей используют scs-тексты как исходные данные для страниц (тексты, которые могут быть обработаны машиной). Данный инструмент визуализирует scs-тексты с помощью SCn-кода, по которым можно осуществлять навигацию.</p>

<p>
<a href="http://itmages.ru/image/view/618834/edbcdbd1"><img src="http://storage5.static.itmages.ru/i/12/0801/s_1343816600_3483259_edbcdbd16d.png"/></a>
</p>

<p>
Подробнее:
<a href="http://blog.ostis.net/?p=256">blog.ostis.net/?p=256</a>
</p>


<h2>15.11.2012 - Открытые семантические технологии проектирования интеллектуальных систем – OSTIS-2013</h2>

<p>21 – 23 февраля 2013 в г. Минск (Республика Беларусь) пройдет III Международная научно-техническая конференция «Открытые семантические технологии проектирования интеллектуальных систем» Open Semantic Technologies for Intelligent Systems OSTIS-2013.</p>

<p>Конференция пройдет в период с 21 по 23 февраля 2013 года в Белорусском государственном университете информатики и радиоэлектроники.</p>

<p>
Информационное письмо конференции можно прочитать
<a href="http://conf.ostis.net/images/0/03/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D0%B8%D1%81%D1%8C%D0%BC%D0%BE_OSTIS-2013.pdf">здесь</a>.
</p>

<p>
Источник:
<a href="http://shcherbak.net/2012/11/otkrytye-semanticheskie-texnologii-proektirovaniya-intellektualnyx-sistem-ostis-2012/">shcherbak.net/2012/11/otkrytye-semanticheskie-texnologii-proektirovaniya-intellektualnyx-sistem-ostis-2012</a>
</p>


<!-- If you add a new language here, please advise prof1983@yandex.ru -->


<!-- footer begin -->

<br/>

<script type="text/javascript"><!--
google_ad_client = "ca-pub-2346392510564999";
/* AiKernel-728x90 */
google_ad_slot = "5007116338";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</td><td width="160">

<script type="text/javascript"><!--
google_ad_client = "ca-pub-2346392510564999";
/* AiKernel-160x600 */
google_ad_slot = "6113788957";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</td></tr>
</table>

<!-- footer end -->

<p><font size=2>
<hr>&copy; AiKernel 2010-2013
<br>15.04.2012 - 15.01.2013
</font>
</body>
</html>
