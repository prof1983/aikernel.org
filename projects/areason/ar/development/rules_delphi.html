<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
  <meta http-equiv="Content-Language" content="ru">
  <title>Правила оформления исходных кодов на Delphi</title>
  <link rel="stylesheet" type="text/css" href="../styles.css">
</head>

<body>
<table cellspacing=0 cellpadding=0 width="100%" border=0>
<tr><td width=100><img src="../img/logo.gif"></td><td>
<font size=2>
<a href="../index.html">Prof.AR</a> &rarr;
<a href="index.html">Разработчикам</a> &rarr;
<a href="rules.html">Правила</a> &rarr;
<b>Правила оформления исходных кодов на Delphi</b>
</font>
</td></tr></table>
<hr>

<table cellspacing=0 cellpadding=0 width="100%" border=0>
<tr><td valign=top width=100>
<nobr><font size=2>
</font></nobr>

</td><td>

<h1>Правила оформления исходных кодов на Delphi</h1>
<p>Объекты в программировании</p>

<h2>1. НАИМЕНОВАНИЕ ПЕРЕМЕННЫХ</h2>
Имя переменной в среде «Delphi» == «Имя переменной», где «Типизированный префикс» имеет следующие значения:
-	«Типизированный префикс» для переменных языка Pascal:
•	s 	== String	
•	i 	== Integer
•	w 	== WORD
•	dw 	== DWORD
•	by	== BYTE
•	b 	== BOOL
•	ch 	== CHAR
•	wsh 	== WideChar
•	ws 	== WideString
•	ui 	== UINT
•	l 	== LONG
•	h 	== HANDLE
•	p 	== POINTER
•	I 	== INTERFACE
•	v 	== VARIANT
•	ov	== OleVariant
•	d 	== DOUBLE
-	«Типизированный префикс» для переменных компонентов форм:
•	btn 	== TButton, TBitButton;
•	grid 	== TGrid,TDBGrid;
•	lаb 	== TLabel;
•	ed 	== TEdit, TdbEdit, TExtDbEdit;
•	cb 	== TComboBox;
•	chb 	== TCheckBox;
•	pan 	== TPanel;
•	mem	== TMemo;
•	al 	== TActionList;
•	act 	== TAction;
•	sb 	== TStatusBar.
Имена переменных указателей формируются путем добавления к «Имя переменной» префикса «p».
В зависимости от области видимости, дополнительные префиксы имеют следующие переменные: 
-	Глобальная переменная == префикс «g_» + «Имя переменной».
-	Переменная член класса == префикс «m_» + «Имя переменной».
Временные (регистровые) локальные переменные возможно называть следующим образом: ii, jj, kk и т.д. Не допускаются имена переменных состоящих из одной буквы.
Пример: 
•	iStatus (переменная типа «int»);
•	piStatus (переменная указатель на «int»);
•	g_iStatus (глобальная переменная типа «int»);
•	m_iStatus (переменная типа «int», член класса);
•	m_piStatus (переменная указатель на «int», член класса);

<h2>2. НАИМЕНОВАНИЕ СВОЙСТВ.</h2>
Именование свойств подчиняется правилу образования «Составное имя».

<h2>3. НАИМЕНОВАНИЕ КОНСТАНТ</h2>
«Имя Константы» — сочетание «Имя» или сокращений на английском языке прописными буквами разделенные символом подчеркивания. Константы определяющие различные значения одного свойства (типа) должны начинаться одинаково и отличаться последней частью наименования.
Пример: 
•	RETURN_TYPE_NONE = 0 (константа «возвращаемые значения»); 
•	RETURN_TYPE_BREAK = 1 (константа «возвращаемые значения»);
•	RETURN_TYPE_CONTINUE = 1 (константа «возвращаемые значения»);
•	EMSG_REQUEST = ‘Ошибка выполнения запроса’ (константа «сообщения об ошибках»)
•	EMSG_INVALID_TYPE = ‘Инвалидный тип’ (константа «сообщения об ошибках»)
•	TABLE_DESC = record (структура для описания таблицы)

<h2>4. НАИМЕНОВАНИЕ КЛАССОВ</h2>
«Имя класса» == префикс «C» + «Составное имя». 
«Имя класса формы» (для форм созданных дизайнером Delphi) == префикс «Т» + «Составное имя» + постфикс «Form». 
Пример: 
•	CPresistConnection; 
•	CStrArray; 
•	TMainForm;
•	TAboutForm.
 
<h2>5. НАИМЕНОВАНИЕ МОДУЛЕЙ</h2>
«Имя модуля» == «Имя класса», в нем реализованного, без префикса «C». 
«Имя модуля формы» (для форм созданных дизайнером Delphi) == «Имя класса формы» без префикса «Т» + постфикс «Unit».
Модули, не содержащие классов, формируются группировкой схожих по области применения или функционалу (в случае процедур и функции) наборов и  именуются по следующим правилам:
-	наборы общесистемных процедур и функции  именуют по правилу «Составное имя» + «Tool»
-	наборы констант «Составное имя» + «Const»
Если модуль является переводом заголовочного файла C/C++, то паскалевский эквивалент должен иметь идентичное  имя и расширение «.pas».
При создании новых модулей необходимо, по возможности, придерживаться правила: один модуль — один класс, не использовать русских наименований каталогов проектов.
Пример: 
•	PresistConnection.pas; 
•	StrArray.pas; 
•	MainFormUnit.pas;
•	AboutFormUnit.pas.

<h2>6. НАИМЕНОВАНИЕ МЕТОДОВ</h2>
«Имя функции» ==:
•	Префикс «Is» + «Составное имя» — для функций, возвращающих булево значение;
•	«Составное имя» — для функций—команд;
•	Префикс «Get» + «Составное имя» — для остальных функций;
«Имя процедуры» == «Составное имя»;
«Приватные методы класса» == префикс «h_» + имя метода;
«Статические методы модуля» == префикс «s_» + имя метода;
Под именем метода подразумевается «Имя функции» или «Имя процедуры».
Пример: 
•	IsDone (функция возвращает true/false);
•	GetCurrentDate (функция возвращает дату).
•	OpenSQL (функция-команда возвращает курсор)
•	h_GetOptions (приватная функция класса)

<h2>7. ПАРАМЕТРЫ МЕТОДОВ</h2>
16.1. Использование модификатора «Var» в объявлении параметров процедур должно  быть исключено. В объявлении параметров функций допускается использование данного модификатора, при условии, что иная реализация невозможна. 
16.2. Строковые параметры методов должны объявляться только с модификатором «Const» или «Var». 
Пример: 
•	Function FindItem(Const sItemName: string; Var iFoundIndex: Integer): Boolean;

<h2>8. СТИЛИСТИЧЕСКОЕ ОФОРМЛЕНИЕ</h2>
17.1. Ключевые слова «then», «do» должны находиться на той же строке, что и условное выражение. Текст кода, следующий за данными ключевыми словами, должен располагаться на следующей строке и быть смещен на один символ табуляции:
If 1<>1 then
exit;
While ii< 100 do
	Inc(ii);
17.2. Оформление блока.
Открывающее блок слово «begin» может находится:
-	На той же строке, что и условный выражение;
-	На следующей строке, на уровне (по левому краю) условного выражения. 
Текст кода внутри блока должен быть смещен на один символ табуляции. 
Табуляция устанавливается фиксированным значением 2 (Tools-Editor Options-Source Options-Tab stops = 2)
Закрывающее блок слово «end» всегда должно быть на новой строке на уровне (по левому краю) условного выражения.
Начало обратной конструкции else должно находиться на одном уровне (по левому краю) с началом условного блока if. Все ветвления условного блока оформляются на одном уровне:
if <Условие1> then begin
	<code>;
end else if <Условие2> then
	<code>;
else if <Условие3> then
	<code>;
else
	<code>;
17.3. Не использовать сложные, вложенные условия. Где это возможно использовать код в виде заглушек:
if <Условие1> then
	exit;
if <Условие2> then
	exit;
17.4. Все операторы языка в коде программы должны быть оформлены с обоих сторон пробелами. 
17.5. Оператор ‘=’ в блоке объявления констант и символ ‘:’ (двоеточие)  в блоке объявления переменных и констант допускается оформлять несколькими пробелами с обоих сторон для выравнивания на одном уровне. 
17.6. В блоке объявления переменных и констант, двоеточие может следовать сразу за именем переменной.
17.7. Символы ‘;’ (точка с запятой) и ‘,’ (запятая) всегда «приклеены» к слову находящемуся слева и отделены одним пробелом от слова находящегося справа. Не допускается оформлять эти символы пробелами с двух сторон.

<h2>9. СОГЛАШЕНИЕ ОБ ОГРАНИЧЕНИЯХ</h2>
18.1. Все постоянные величины должны быть, перед их использованием в тексте программного кода,  предварительно оформлены в виде значений констант.
18.2. Запрещается:
-	Использование конструкции с ключевым словом «with»;
-	Наличие в программах неиспользуемых идентификаторов. Неиспользуемые идентификаторы появляются, как правило, после модификаций в программах. Происходят изменения в секции реализации, но не делаются соответствующие изменения в секции определений.
-	Использование одного идентификатора для разных целей. Изначально идентификатор создается для определенной цели, но затем, после выполнения этой цели, он используется для других целей.
-	Наличие в программах закомментированного кода.

<h2>10. ВНЕСЕНИЕ ИЗМЕНЕНИЙ В РАБОЧИЙ КОД</h2>
Внесение изменений в уже используемый, общий код необходимо фиксировать новым правилом.
Правило имеет следующую структуру: префикс «CORRECTION_»  + дата в формате (yyyymmdd) +  “_” + псевдоним программиста + “_” +  «Имя Константы» отражающее смыл изменений. 
Пример: 
{$define  CORRECTION_20050408_DIN_MENUBUG}
Блок изменений оформляется:
{$ifdef CORRECTION_20050408_DIN_MENUBUG}
измененный вариант кода;
{$else}
Исходный вариант кода;
{$endif}
Устоявшиеся и отработанные правила подлежат утверждению и внесению в состав модуля только измененного варианта с полным удалением исходного.

<h2>11. ДОКУМЕНТИРОВАНИЕ И КОММЕНТАРИИ.</h2>
Синтаксическое оформление комментариев: 
-	Однострочный комментарий == // Комментарий
-	Многострочный комментарий == {: Комментарий }
Все программные модули должны быть иметь заголовок следующего содержания:
-	Общее описание модуля;
-	Дату написания модуля;
-	Автор;
-	TODO (памятка, что необходимо сделать, рекомендации);
-	Историю изменений (дата, автор, причина/назначение);
Все вспомогательные классы и их члены, переменные и функции модулей общего назначения должны предваряться группой однострочных комментариев с описанием их назначения.

</td></tr></table>

<font size=2>
<hr><a href="mailto:Prof5@mail.ru">E-mail</a>
<br>&copy; <a href="http://prof1983.narod.ru/">Prof</a> 2007
<br>12.03.2007
</font>
</body>
</html>