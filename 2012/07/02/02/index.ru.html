<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="ru">
<meta name="Keywords" content="AI, ИИ, Artificial Intelligence, Искусственный Интеллект, Artificial Reason, Искусственный Разум, Robot, Робот, Robots, Роботы">
<title>AiKernel - Размышления об алгоритме разума - AReasoner</title>
<link rel="stylesheet" type="text/css" href="../../../../styles.css">
</head>

<body>


<!--- header begin --->
<table border="0" width="100%">
<tr><td>
<!--- header end --->


<p><a href="index.en.html">en</a> <b>ru</b></p>

<h1>Размышления об алгоритме разума - AReasoner</h1>

<p>Продолжим. Есть разные теории как эти свойства можно получить в компьютерной программе (в частности всевозможные нейронные системы, автоматы, логический подход и др).</p>

<p>Лично мне наиболее близок логический подход, но в известных мне алгоритмах есть некоторые ограничения, которые не позволют создать достаточной большую систему с множеством противоречивых (а иногда и взаимоисключающих) знаний. Универсального и более или менее удовлетворительного подхода для решения этой проблемы пока не найдено. Поэтому я постараюсь описать свою теорию как создать универсальный алгоритм для агентов.</p>

<h2>AReasoner</h2>

<p>AReasoner - решатель или движок логического вывода.</p>

<p>
Состав:
<br/>1. Локальная модель мира (онтология).
<br/>2. Алгоритм разума.
</p>

<h3>Локальная модель мира (онтология)</h3>
<p>
<br/>1. Локальная модель - это онтология.
<br/>2. Онтология не полная, но с возможностью частичного пополнения из основной (глобальной) БЗ и из внешних источников.
<br/>3. Онтология состоит из онтологических атомарных единиц (далее сущности).
<br/>4. Модель (локальная онтология) содержит в том числе еще и дополнительные ассоциативные связи между элементами.
<br/>5. Ассоциативные связи имеют рад параметров. В частности: вес, надежность, достоверноесть.
</p>

<h3>Алгоритм разума</h3>
<p>
<br/>1. Подготовка: заполнение начальной онтологии с исходными данными.
<br/>2. Постановка задачи (цели).
<br/>3. Запуск алгоритма на выполнение.
<br/>4. Работа алгоритма. Во время работы может осуществляться запрос дополнительных данных (исходных данных) и запрос недостающих знаний из БЗ (блоков знаний).
<br/>5. Вывод результатов и запись результатов в БЗ.
<br/>6. Выход из алгоритма.
</p>

<h3>Описание алгоритма</h3>
<p>
<br/>1. Алгоритм последовательно просматривает все онтологические единицы (сущности) тукущем отображении, применяет к ним правила логического вывода и, таким образом, меняет локальную модель мира.
<br/>2. Текущая модуль (отображение) содердит как элементы мира, так и дополнительные (пока не существующие в глобальной БЗ) наложенные на модель мира элементы.
<br/>3. Размер текущей модели мира ограничен размерами выделенной оперативной памятью. Поэтому, естественно в "поле зрения" алгоритма не могут присутствовать все знания.
<br/>4. В текущую онтологию включаются ассоциативные сущности. При этом учитыватся "вес" ассоциативной связи.
<br/>5. Вес ассоциативной связи зависит от текущего контента и в разных ситуациях может отличаться.
<br/>6. В алгоритме присутсвует так же понятие "внимания". Это численное значение элементов, которые используются чаще других. У таких элементов "вес" увеличивается, а так же увеличивается вес ассоциированных с ним элементов.
</p>

<h3>Пример</h3>

<p>Например у нас имеется некоторое знание об автомобиле. У автомобиля очень много элементов и, соответсвенно, в системе может находится очень большое кол-во знаний об автомобиле. При этом все знания, так или иначе связаны между собой. Естественно просмотреть и учесть все знания в разумных временных рамках невозможно. Поэтому учытываются только те знания об элементе "автомобиль", которые имеют наибольший вес в текущем контексте. Пусть, к примеру текущим контекстом будет "неполадка двигателя".</p>

<p>По этим двум элементам система автоматически загрузит из БЗ наиболее "весомые" элементы (такие как "двигатель", "карбюратор", "топливо" и т.д.). Элементов будет столько на сколько хватит выделенной оперативной памяти.</p>

<p>Далее запускатся алгоритм обхода загруженных элементов с просмотром и применением правил для онтологических единиц. Для тех элементов, которые рассматриваются в данный момент и чаще всего (те на которые система обращает "внимание") - у таких элементов увеличивается вес. Периодически элементы в оперативной памяти (в текущей онтологии) с низким весом выгружаются и заменяются на элементы с высоким показателем веса.</p>

<p>Таким образом обеспечивается плавное "перетекание" мысли от одного к другому. Так же, в общем-то, осуществляется процесс мышления у человека (и, вероятно, у других животных).</p>

<p>Если понаблюдать за собственным ходом мыслей, то это легко обнаружить. :)</p>


<p>Обсуждение: <a href="http://www.project-ai.org/forum/viewtopic.php?t=56">project-ai.org/forum/viewtopic.php?t=56</a></p>



<!--- footer begin --->

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>


<script type="text/javascript"><!--
google_ad_client = "ca-pub-2346392510564999";
/* AiKernel-728x90 */
google_ad_slot = "5007116338";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</td><td width="160">

<script type="text/javascript"><!--
google_ad_client = "ca-pub-2346392510564999";
/* AiKernel-160x600 */
google_ad_slot = "6113788957";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</td></tr>
</table>

<!--- footer end --->


<!--- If you add a new language here, please advise prof1983@yandex.ru --->

<p><font size=2>
<hr>&copy; AiKernel 2010-2013
<br>02.07.2012 - 28.12.2012
</font></p>
</body>
</html>
